[
  {
    "Id": "976282",
    "ThreadId": "423496",
    "Html": "\r\n<p>Our development process includes simultaneous development on multiple release paths: while one team is working on the current major release another team is working on the next major and a third team may be work on the one after that. &nbsp;Of course the\r\n standard branches for ServicePack and HotFix work on the current production version also exist. &nbsp;Our problem is that we want to provide a simple merge path from main through all of the development branches. &nbsp;We are focusing on trying to (1) minimize\r\n the number of merges required for each check in and (2) protect main from becoming polluted with accidental merges from future release branches. &nbsp;The recommended advanced branching pattern suggests creating all of the future release branches at the same\r\n time with MAIN as the root:</p>\r\n<p>MAIN<br>\r\n---| RELEASE_1<br>\r\n---| RELEASE_2<br>\r\n---| RELEASE_3</p>\r\n<p>My primary issue with this scheme is that changes checked into RELEASE_1 then have to be merged forward into RELEASE_2 and RELEASE_3 through MAIN. &nbsp;It quickly becomes difficult to track what items haven't been merged forward and to which branches. &nbsp;Plus\r\n it is difficult to protect MAIN from accidental reverse integration merges from RELEASE_2 and RELEASE_3 while RELEASE_1 is still active.</p>\r\n<p>I am proposing a modified hierarchical branch structure where RELEASE_2 is a child of RELEASE_1 and RELEASE_3 is a child of RELEASE_2. &nbsp;</p>\r\n<p>MAIN<br>\r\n---| RELEASE_1<br>\r\n------| RELEASE_2<br>\r\n---------| RELEASE_3</p>\r\n<p>Then as each version is released to production, its child branches could be reparented to MAIN and that branch could be locked to prevent further checkins. &nbsp;This allows for a straightforward, sequential merge path and gives us the ability to protect\r\n main by denying reverse integration merges on all of the release branches. &nbsp;We can easily monitor what changes haven't been merged into the future releases (everything should always merge forward). &nbsp;By denying reverse integration merges on the release\r\n branches, we protect MAIN and ensure that it is only receiving changes from the current release branch. &nbsp;The only hiccup with this plan that I can see (and it seems minor to me) is that after reparenting, we will have to re-merge every change that was\r\n checked into RELEASE_2 back into MAIN. &nbsp;But as long as we manage our forward integration merges and make sure that the merge list is clear before performing the reparent, this should be a simple overwrite merge (any conflicts should have been resolved\r\n by the merge from RELEASE_1 -&gt; RELEASE_2).</p>\r\n<p>Thoughts? &nbsp;Comments? &nbsp;What am I missing?</p>\r\n",
    "PostedDate": "2012-12-26T06:40:05.193-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "976626",
    "ThreadId": "423496",
    "Html": "\r\n<div>Under your original plan, Why would you ever merge release 2 or release three Into the main branch until release one is deployed into production?<br>\r\n<br>\r\nSent from my iPhone</div>\r\n<div><br>\r\nOn Dec 26, 2012, at 9:40 AM, LostArchitect &lt;<a href=\"mailto:notifications@codeplex.com\">notifications@codeplex.com</a>&gt; wrote:<br>\r\n<br>\r\n</div>\r\n<blockquote type=\"cite\">\r\n<div>\r\n<p>From: LostArchitect</p>\r\n<div id=\"ThreadNotificationPostBody\">\r\n<p>Our development process includes simultaneous development on multiple release paths: while one team is working on the current major release another team is working on the next major and a third team may be work on the one after that. Of course the standard\r\n branches for ServicePack and HotFix work on the current production version also exist. Our problem is that we want to provide a simple merge path from main through all of the development branches. We are focusing on trying to (1) minimize the number of merges\r\n required for each check in and (2) protect main from becoming polluted with accidental merges from future release branches. The recommended advanced branching pattern suggests creating all of the future release branches at the same time with MAIN as the root:</p>\r\n<p>MAIN<br>\r\n|- RELEASE_1<br>\r\n|- RELEASE_2<br>\r\n|- RELEASE_3</p>\r\n<p>My primary issue with this scheme is that changes checked into RELEASE_1 then have to be merged forward into RELEASE_2 and RELEASE_3 through MAIN. It quickly becomes difficult to track what items haven't been merged forward and to which branches. Plus it\r\n is difficult to protect MAIN from accidental reverse integration merges from RELEASE_2 and RELEASE_3 while RELEASE_1 is still active.</p>\r\n<p>I am proposing a modified hierarchical branch structure where RELEASE_2 is a child of RELEASE_1 and RELEASE_3 is a child of RELEASE_2.\r\n</p>\r\n<p>MAIN<br>\r\n|- RELEASE_1<br>\r\n|- RELEASE_2<br>\r\n|- RELEASE_3</p>\r\n<p>Then as each version is released to production, its child branches could be reparented to MAIN and that branch could be locked to prevent further checkins. This allows for a straightforward, sequential merge path and gives us the ability to protect main\r\n by denying reverse integration merges on all of the release branches. We can easily monitor what changes haven't been merged into the future releases (everything should always merge forward). By denying reverse integration merges on the release branches, we\r\n protect MAIN and ensure that it is only receiving changes from the current release branch. The only hiccup with this plan that I can see (and it seems minor to me) is that after reparenting, we will have to re-merge every change that was checked into RELEASE_2\r\n back into MAIN. But as long as we manage our forward integration merges and make sure that the merge list is clear before performing the reparent, this should be a simple overwrite merge (any conflicts should have been resolved by the merge from RELEASE_1\r\n -&gt; RELEASE_2).</p>\r\n<p>Thoughts? Comments? What am I missing?</p>\r\n</div>\r\n</div>\r\n</blockquote>\r\n",
    "PostedDate": "2012-12-26T08:04:49.46-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "976683",
    "ThreadId": "423496",
    "Html": "\r\n<p>It shouldn't happen, but I'm trying to protect against accidents. &nbsp;In my environment developers swap teams frequently. &nbsp;A dev who was working on RELEASE_1 yesterday could easily be working on RELEASE_2 tomorrow. &nbsp;Given that condition, I can easily&nbsp;foresee&nbsp;a\r\n situation where a dev get's confused and (thinking that he is working on the current release) accidentally performs a reverse integration merge from RELEASE_2 into MAIN effectively promoting code ahead of schedule. &nbsp;My second scheme is focused on trying to\r\n prevent this.</p>\r\n",
    "PostedDate": "2012-12-26T08:21:48.06-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "977663",
    "ThreadId": "423496",
    "Html": "\r\n<div>If they accidentally merge from rls 3 to rls 1, it will pollute rls 1 just as it would have polluted the main branch. Then when you go to merge rls 1, it has the release 3 stuff in it. I don't see what you gained.\r\n</div>\r\n<div><br>\r\n</div>\r\n<div>The fact that you have 3 releases going on at one time is disturbing. Especially since you said some of the same people are working on multiple releases. This is highly inefficient. They could be more effective concentrating on finishing the first release.\r\n This parallelism provides the illusion of great activity. But it is actually a slower way to get results. There appear to be deeper issues here of release planning and program management. It might be useful to explore your broader problems rather than thinking\r\n this is just a branch design issue. <br>\r\n<br>\r\nSent from my iPhone</div>\r\n<div><br>\r\nOn Dec 26, 2012, at 11:22 AM, lostarchitect &lt;<a href=\"mailto:notifications@codeplex.com\">notifications@codeplex.com</a>&gt; wrote:<br>\r\n<br>\r\n</div>\r\n<div><span></span></div>\r\n<blockquote type=\"cite\">\r\n<div>\r\n<p>From: lostarchitect</p>\r\n<div id=\"ThreadNotificationPostBody\">\r\n<p>It shouldn't happen, but I'm trying to protect against accidents. In my environment developers swap teams frequently. A dev who was working on RELEASE_1 yesterday could easily be working on RELEASE_2 tomorrow. Given that condition, I can easily foresee a\r\n situation where a dev get's confused and (thinking that he is working on the current release) accidentally performs a reverse integration merge from RELEASE_2 into MAIN effectively promoting code ahead of schedule. My second scheme is focused on trying to\r\n prevent this.</p>\r\n</div>\r\n</div>\r\n</blockquote>\r\n",
    "PostedDate": "2012-12-26T11:45:29.59-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "977867",
    "ThreadId": "423496",
    "Html": "\r\n<p>I addressed that possibility as well in my proposed scheme. &nbsp;By denying the ability to perform reverse integration merges on the release branches we do not allow for the possibility of merging from RELEASE_3 into RELEASE_2 or RELEASE_2 into RELEASE_1. &nbsp;This\r\n can be simply implemented with a custom check-in policy. &nbsp;Putting a similar restriction on MAIN with a growing set of separate child branches would be more difficult. &nbsp;The gains from this scheme are (repeated as listed above):</p>\r\n<ol>\r\n<li>A sequential merge path from 1 -&gt; 2 -&gt; 3 (as opposed to 1 -&gt; Main, Main -&gt; 2, Main -&gt; 3)\r\n<ul>\r\n<li>This also guarantees that all changes from RELEASE_1 will get merged into future branches, rather than being left behind on the MAIN line and never merged forward\r\n</li></ul>\r\n</li><li>Faster utilization of new features implemented in previous releases (available immediately upon forward integration merge)\r\n</li><li>Identifying unmerged items for branches RELEASE_2 and RELEASE_3 is very simple (everything should always merge)\r\n</li><li>It is easier to protect MAIN against accidental reverse integration merges from future release branches\r\n</li></ol>\r\n<p>In short, I believe that this offers greater synchronization between the branches with the least amount of effort for both the developers and the build master/TFS admin.</p>\r\n<p>Project management is beyond the scope of the problem which I am addressing here. &nbsp;I am trying to design a safe and efficient branching structure based on the development environment as it exists. &nbsp;I believe that this scheme does that, but would appreciate\r\n any input that shows flaws in the design or gaps in my logic.</p>\r\n",
    "PostedDate": "2012-12-26T12:24:20.6-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "981013",
    "ThreadId": "423496",
    "Html": "\r\n<p>Is there a possibility of two versions released at the same time?&nbsp; I doubt that would happen.&nbsp; A more managable approach would be to have one Service Pack branch off of main and branch your releases from Service Pack.&nbsp; Any production bug fixes\r\n would be done in Service Pack and the new version would be branched off of there.&nbsp; When you are ready to reverse integrate, it would be from Service Pack to Main and FI to development.&nbsp; Any new development versions that are ready to be released are\r\n forward integrated from Main to SP and then an immediate branch from SP to Release_x.&nbsp; Since one version is live at a time, there is little need for each Release branch to have its own SP or hotfix or to branch future releases until they are ready to\r\n go live.</p>\r\n<ul>\r\n<li>Main\r\n<ul>\r\n<li>SP\r\n<ul>\r\n<li>Release_1 </li><li>Release_2 </li><li>etc. </li></ul>\r\n</li></ul>\r\n</li></ul>\r\n",
    "PostedDate": "2012-12-27T14:38:24.213-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]