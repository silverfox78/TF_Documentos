[
  {
    "Id": "666316",
    "ThreadId": "271159",
    "Html": "<p>I'm trying to see if adopting a branching strategy would benefit us. Here is our current process. Concurrent development has only happened accidentally twice in my five years with the company. Typically, work on vNext+1 does not take place until vNext is released.</p>\n<ol>\n<li>Changes developed. </li>\n<li>Changes submitted to testers (black-box testing only) </li>\n<li>If&nbsp;testing finds bugs, bugs fixed, resubmitted to testers. Otherwise, changes are released. </li>\n</ol>\n<p>We are using a product called MKS to handle source control. It supports labeling files and checkpointing a project. When the changes are developed, we label the deliverables with the file version and checkpoint the project with the application version. Checkpointing gives us a way to retrieve an exact copy of the source as it existed when it was checkpointed. The file version and app version are incremented every time it's submitted to the testers. So 1.0 is submitted, testers find bugs, devs fix and submit 1.0.1. Version 1.0.1 is released, bugs found, devs fix, submit 1.0.2 to testers. When new features are added, 1.1 or 2.0 (depending on magnitude of changes) is submitted to testers and process repeats.</p>\n<p>What would the benefits be to adopting a branching strategy (such as the Basic or Standard strategies described here)? Aside from allowing concurrent development (which would happen rarely)&nbsp;and&nbsp;a way to imitate MKS checkpoints with read-only Release branches, I can't see any.</p>\n<p>Maybe I'm just misunderstanding things? Here's what I got from the Basic plan.</p>\n<ul>\n<li>Dev branch is for current dev work. Once changes are complete and judged ready for testing, they get merged with the Main branch. </li>\n<li>Testing occurs on the Main branch and any bugs found during testing are fixed there. </li>\n<li>When testing passes, the code is branched into&nbsp;the Release branch and the branch is labeled with the version. If bugs are found in production, the bug fixes and testing occurs in the Release branch. These changes are merged into the Main branch and are then merged into the Dev branch if dev work is occuring.</li>\n</ul>\n<p>Did I get it right?</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>",
    "PostedDate": "2011-09-01T08:46:23.83-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "666341",
    "ThreadId": "271159",
    "Html": "<p>I think you have a pretty clear picture. One diference with Team Foundation Server is that labels are NOT immutable. Therefore one needs to be careful when using labels to lock-down a version of code. This is a clear benefit of read-only branches.</p>\n<p>I am not familiar with MKS and how code is *pulled* and then built and deployed to either a testing environment or production environment. A key reason for branches on the *release* side of the branching model is to isolate post-release bug fixes or service packs (which are made to vCurrent or older production code) from new developement happening on vNext. If we did not isolate these activities in TFS with branches, it would be impossible for a production fix to vCurrent&nbsp;be checked into TFS and at the same time check-in changes to vNext. In our model production fixes (on the basic plan) are checked into the release branch. New developement happens for vNext in the development branch. No changes are checked into the Main branch - it should be as stable as possible. Changes are merged after testing into the Main branch (either from the release branch to bring a hot fix forward into vNext development, or from the development branch when it passes quality gates and is ready for final stablization in the Main branch.</p>\n<p>Note - in the basic branch plan you have to make a choice - if you make the release branch read-only then clearly it cannot also be used for post-release sustained engineering. This is when you go to the standard plan where you have a servicing branch AND a release (read-only) branch.</p>\n<p>I hope this helps</p>\n<p>Regards,<br />Bill Heys<br />VS ALM Ranger and WW Lead for Microsoft Services WW ALM Community.</p>",
    "PostedDate": "2011-09-01T09:25:09.383-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "666355",
    "ThreadId": "271159",
    "Html": "<p>Thanks for the quick reply, Bill. I forgot to mention that we're evaluating TFS 2010. MKS can be quite clunky.</p>\n<p>To answer your questions, MKS does not have automated build support (or if it does, we aren't using it). Code is built on the developer's machine and the binaries are stored with the source. Not the best solution, but our software is all internal so it works for us. Most of our software&nbsp;uses a&nbsp;simple client-server architecture, so it's a simple switch of a setting to&nbsp;connect to our test database or the production database.</p>\n<p>MKS labels are mutable, but checkpoints are not. Labels happen at a file level, while checkpoints happen at the project level. It is simple to go into the project history and choose a checkpoint to look at. If changes are needed, a branch can be created from this checkpoint, changes made, and then the changes merged back into the trunk/main.</p>\n<p>You say no check-ins happen in the main branch. So bug fixes for bugs found in the main branch&nbsp;would happen in the dev branch and then it would be merged back to the Main branch for testing?</p>\n<p>I understand the Standard plan inserts a Hotfix/SP branch to handle addressing problems in the Release branches, which would keep the Release branch read-only. This would probably better duplicate the MKS checkpoint functionality.</p>\n<p>&nbsp;</p>\n<p>To make sure I'm understanding things, this is what the branches would look like if we labeled all merges and check-ins.</p>\n<p>Dev -&gt; checkin---checkin---1.0 sent to main---bugs fixed, checkin---1.0.1 sent to main---checkin---checkin---1.0.2 merged with 1.1 work&gt;</p>\n<p>Main -&gt;1.0---tested, bugs found, sent back to dev---1.0.1---no bugs, sent to release---1.0.2---1.0.2 sent to dev---&gt;</p>\n<p>Release -&gt; 1.0.1---bugs found---bugs fixed, checkin---tested, good---1.0.2 release, sent to main---&gt;</p>",
    "PostedDate": "2011-09-01T09:51:22.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "666364",
    "ThreadId": "271159",
    "Html": "<p>At a high level, I agree with your flow. I might word things a little differently:</p>\r\n<p>Dev -&gt; checkin---checkin---1.0 <strong>labeled and merged&nbsp;(RI) </strong>to main---bugs fixed, checkin---1.0.1 <strong>labeled and merged (RI)&nbsp;</strong>to main---checkin---checkin---1.0.2 <strong>(merged from Main (FI)&nbsp;and combined</strong>&nbsp;with 1.1 work&gt;</p>\r\n<p>Main -&gt;1.0 <strong>(merged&nbsp; (RI)from Dev )</strong>---tested, bugs found, sent back to dev <strong>(essentially the bugs are sent to the developers who fix them in the dev branch)</strong>---1.0.1 <strong>(merged (RI) from Dev)</strong>---no bugs, <strong>labeled and branched for&nbsp;</strong>release---1.0.2---1.0.2 <strong>(merged from Release (RI)</strong>&nbsp;<strong>and merged (FI)&nbsp;</strong>to dev---&gt;</p>\r\n<p>Release -&gt; 1.0.1 <strong>(branched from Main)</strong>---bugs found---bugs fixed, checkin---tested, good---1.0.2 <strong>labeled and merged (RI)&nbsp;to&nbsp;</strong>main---&gt;</p>\r\n<p>The problem with your illustration is the flows are difficult to line up in a text description but the understanding seems correct.</p>\r\n<p>As an aside, we generally do a daily automated build in Main and, if the build is good Merge (FI) from Main to Dev daily. We probably increment the build and label&nbsp; Main 1.0.0.001, 1.0.0.002, 1.0.1.001 etc. (again being simplistic)</p>\r\n<p>We would only merge from Dev to Main on a milestone (1.0, 1.0.1, etc)<br /><br />I hope this helps<br />Bill Heys</p>",
    "PostedDate": "2011-09-01T10:08:50.12-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "666375",
    "ThreadId": "271159",
    "Html": "<p>Thanks Bill, I think I've got it.</p>\r\n<p>So in the Standard plan, you'd have a new read-only&nbsp;release branch for each release, and post-release defect fixing would happen and be tested in the servicepack/hotfix branch? That seems like a cleaner approach than the Basic plan.</p>\r\n<p>&nbsp;</p>\r\n<p>Now, bearing in mind that concurrent development almost never happens here, and post-release defect fixes&nbsp;are bundled with vNext, do you think that we would benefit much from branching?</p>",
    "PostedDate": "2011-09-01T10:23:12.083-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]