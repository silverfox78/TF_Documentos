[
  {
    "Id": "523618",
    "ThreadId": "235125",
    "Html": "\r\n<p><span style=\"font-size:10pt; color:black\">I have the challenge of designing a new approach to our code/branch management in TFS 2005.&nbsp;&nbsp;&nbsp; Our current approach has static code branches that represent various test environments.&nbsp;&nbsp;&nbsp;\r\n We built this approach before the rangers and with little documentation. It lacks the flexibility we need to support multiple clients and concurrent development and release testing.\r\n</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">I have studied the Standard and advance branch concepts&hellip; and had some questions..</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">1.</span><span style=\"font-size:7pt; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span><span style=\"font-size:10pt; color:black\">&nbsp;Where do I build from for test (release 1, release 2, etc). I think you build from Main, I may have two or three test code bases at the same time.&nbsp;&nbsp; Release 1 current with 2 and maybe 3. &nbsp;</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">2.</span><span style=\"font-size:7pt; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span><span style=\"font-size:10pt; color:black\">Do you deploy production from a different release branch each&nbsp;time?&nbsp; What tool/approach do you use to make sure that you build production from the correct branch? We currently build from the same branch\r\n (prod) all the time. If you do a hot fix for release 1 do you make the changes in the &ldquo;release 1 fix branch&rdquo; and merge to the release branch? How do you manage security for these branches? Do you unlock the hot fix branch only for the developer\r\n working on the fix?</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">3.</span><span style=\"font-size:7pt; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span><span style=\"font-size:10pt; color:black\">&nbsp;I may need to support two test environments UAT1 and UAT2 &ndash; based on client needs.&nbsp;&nbsp; What is the best approach to automating this build process when my code source may come from different\r\n branches?</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">4.</span><span style=\"font-size:7pt; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span><span style=\"font-size:10pt; color:black\">What triggers the move from Main (UAT) to the release branch? Is this after UAT is complete or before? What triggers code to merge from Devl to Main?</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">6. Merges can be complex. I am very concerned about the time required for merging code and resolving issues. What are the tips and tricks to making this work?&nbsp;&nbsp; Specifically I am concerned about merging\r\n the DB Schema. &nbsp;DBPRO is good, but it doesn&rsquo;t do the schema to our standards, we do the DB schema merges manually (compare, asses and script).</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">Any help you can provide would be appreciated.</span></p>\r\n",
    "PostedDate": "2010-11-17T21:39:17.277-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "523926",
    "ThreadId": "235125",
    "Html": "\r\n<p>If you start by looking at the basic branch plan, here we have three branches: Main, Development, and Release. Let's suggest that there are three releases being supported (Release 1.0 and Release 2.0 are both in production, while Release 3.0 is in development)\r\n Let's call Release 2.0 the *current* release (vCurrent). This makes Release 1.0 vCurrent -1 and next release is Release 3.0 (vNext), which is not yet in production.</p>\r\n<p>The only difference between the basic branch plan and the standard branch plan is that we have added a new *level* of branching on the Release side, the Service Pack branch. This is the branch where post-release hot fixes and / or service pack changes are\r\n made.</p>\r\n<p>Let's suggest that you are getting to the point where you are finalizing vNext (Release 3.0). All of the enhancements for this release have been tested in the Development branch and, when they are ready to be released, are merged into the Main branch. What\r\n triggers a merge from Development to Main? The code in Development must be *feature complete* and tested. The code in Development must pass pre-established quality gates before it can be considered *Ready to be stabilized for Release* or *Ready to Share* or\r\n *Ready for Integration*. You need to determine what you establish for quality gates (typically you track code quality indicators such as rates of new bugs reported, rates of bugs fixed, rates of bugs re-tested and marked complete, etc.). What this means is\r\n you should have a formal QA process to test code in the Development branch *before* it is merged to Main. Bugs in development should be tracked and reported. When you get to the point where the rate of new bugs reported declines (toward zero) and the number\r\n of outstanding bugs declines (towards zero). When you reach a predetermined level of quality, then the code is ready to be released. You should label this code (milestone labels are useful). Then you should merge the code from Development to Main.</p>\r\n<p>The same process applies to code in the Main branch. After the new features are merged for vNext stabilization in Main, you continue to stabilize the code in Main until you reach a pre-determined level of qualtity. When you reach this level of quality, the\r\n code is ready to be shipped. You would not create a Release branch until the code is ready to be shipped and released. The assumption here is that you would complete all testing including UAT before you branch from Main to Release (or Main to SP and SP to\r\n Release).</p>\r\n<p>I look at supporting test environments as a deployment issue, not so much a build issue (although the two are related). Rather than have separate branches for UAT1 and UAT2 (as some suggest), I deploy code from Main to each of the UAT environments. This\r\n allows you to control which build is in each UAT environment and allows bugs to be associated with specific builds. It is difficult for QA if the code in UAT is continually being changed and built. Deployments to QA (UAT) should be controlled so they are testing\r\n a relatively stable code base.</p>\r\n<p>Each branch should have it's own automated build process. There are many flavors of build that you can consider. However, I would strongly suggest that you consider moving to TFS 2005 to TFS 2010 (or even TFS 2008) becuase of improvements that have been\r\n made to MSBuild and Team Build since 2005.&nbsp;Where supported, I recommend implementing Continuous Integration (CI) builds. This means that whenever a developer check-in code to a Development branch, an automated build is automatically triggered. There is\r\n a flavor of this in TFS 2010 - the rolling builds- that queues up check-in triggered builds so that a new build waits until a prior build completes. There is even an option for delaying the next build for a specified period of time so you do not overload the\r\n build server during times when there a many check-in in a short period of time.</p>\r\n<p>We recommend doing daily builds in the Main branch. After a good daily build in Main, we recommend merging Main to the Development branch(es). This reduces the degree to which Main and Development become out of sync. When you do this on a daily basis, there\r\n will be more frequent merges with fewer merge conflicts each time. If you wait a long period of time between merges from Main to Development you will have the *big bang* effect where a lot of merge conflicts may need to be resolved at the same time.</p>\r\n<p>In short, you would deploy from Development to QA for feature testing (you may have more than one feature branch in development). You would deploy from Main to QA for integration testing and for stabilizing the code for release.</p>\r\n<p>How do you ensure you build production from the correct branch? This is why you have a build master. You do not want every developer having the ability to do builds on the Main branch. The build master should be knowledgeable and experienced enough to follow\r\n proper procedures when building for production release. If you have the advanced branch plan (with three levels of branches on the release side), you should be aware that these three branches are created at the same point in time. When the code is ready to\r\n ship, branch Main to Service Pack. Branch Service Pack to Hot Fix, and Branch Hot Fix to Release read-only. You should not have bidirectional branching on the release side of the picture (e.g. you would not merge a hot fix down into the release branch, but\r\n you could merge a hot fix up into the service pack branch and then up to main to bring it forward).</p>\r\n<p>On typical projects you have a variety of roles. On larger teams you might have developers grouped into teams with technical team leads. Then you have focused roles such as project manager, technical team lead, branching lead, build master, release master,\r\n etc. It is difficult to make specific security recommendations that apply generally to a wide variety of situations. At a minimum developers probably need check-in and build privleges on a development branch. Nobody should have check-in privileges on a Main\r\n branch. The build master should have build permissions on the Main branch, etc.</p>\r\n<p>As for locking / unlocking the hot fix branch - this is probably not necessary. Controlling merges involving the hot fix branch seems to me to make more sense.</p>\r\n<p>I am not an expert on DBPRO. I would be interested in hearing of your experiences in this area. What are the shortcomings or challenges you face when managing the schema with DBPro. Perhaps we can forward some ideas along to the product group.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2010-11-18T10:27:03.837-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "525356",
    "ThreadId": "235125",
    "Html": "\r\n<p><span style=\"font-size:10pt; color:black\">Bill,&nbsp; Great Stuff - thanks for the quick response...</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">A few more questions&hellip;</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">1. Ref: &ldquo;Rather than have separate branches for UAT1 and UAT2 (as some suggest), I deploy code from Main to each of the UAT environments. This allows you to control which build is in each UAT environment and\r\n allows bugs to be associated with specific builds. It is difficult for QA if the code in UAT is continually being changed and built.&rdquo;</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">1. Q:&nbsp; I assume that Main is always VNext.&nbsp; The example of UAT1, UAT2, etc.&nbsp; I assume this is the same Vnext code base? - in different test environments?.&nbsp;&nbsp; Vnext &#43;1, &#43;2 would be in two development\r\n branches and merged to Main when Main is ready for Vnext &#43;1 (now Vnext).&nbsp; Is it best practice to merge from MAIN to development and then merge development to MAIN when ready for the next vNext.</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">2.Q: Do you recommend creating development branches by release or by feature? We are often challenged with projects that are targeted for a release but don&rsquo;t make it for numerous reasons. I also want to test\r\n feature dependent releases concurrently.&nbsp;&nbsp; I have the impression that a development branch should be Vnext&#43;1, etc.\r\n</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">3. ref: &ldquo;Nobody should have check-in privileges on a Main branch&rdquo;\r\n</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">3. Q: How do you make bug fixes in Main? Do you create a Main bug fix branch or use a development branch?</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">4. Regarding DBPRO, I can get that list to you. For the sake of discussion, let&rsquo;s say that DBPRO does not exist. What is the best practice for merging DB Schema between the various code branches?</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">Thanks!</span></p>\r\n<p><span style=\"font-size:10pt; color:black\">Tod</span></p>\r\n",
    "PostedDate": "2010-11-22T08:43:00.517-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "525400",
    "ThreadId": "235125",
    "Html": "\r\n<p>If you are working on vNext, vNext &#43;1, vNext &#43;2 all at the same time, you would most likely NEED to have separate Development branches for each of these. It is unusual for companies to be dealing with so many future versions at one time. Perhaps you have\r\n frequent releases that require longer development time frames.</p>\r\n<p>Main is typically dedicated to stabilizing the next release (vNext) before it is released to production. In theory, you would do daily builds in Main and, following each good daily build, do merges (FI) with the development branch(es). You would not merge\r\n the vNext development branch with Main until the vNext development branch is ready to be stabilized for release. At this point merge vNext Development to Main (Main is now used for stabilizing vNext). There may be a period of time between when you release\r\n a version (vCurrent) from Main and you are ready to stabilize vNext. During this period of time Main will be vCurrent (with fixes).</p>\r\n<p>With respect to bug fixes. I prefer the Standard or Advanced branch plan. If you are making bug fixes to released code, make the changes to the SP or Hotfix branch associated with that release, and merge (ri) this hotfix up to Main. If the bug fix is found\r\n during stabilization of code in Main, make the bug fix in the development branch and merge (RI) the fix down to Main. If you are feature testing code in a development branch (before it is ready to merge to Main), make the fix directly in that development branch.</p>\r\n<p>I am not a DBPro exepert, but I will try to get some anwers for you.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger</p>\r\n",
    "PostedDate": "2010-11-22T10:06:09.02-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "525562",
    "ThreadId": "235125",
    "Html": "\r\n<p>Great stuff,</p>\r\n<p>We do monthly releases with many projects that take more than a month. We often need to start v&#43;2 or even V&#43;3 concurrent with V.&nbsp;&nbsp; We currently manage this by having one development branch and promoting to &ldquo;main&rdquo; by project/work item\r\n instead of by branch. It certainly causes a few problems, but it does work.</p>\r\n<p>I assume that when you merge, you are referring to an entire branch merge? Development branch xx merged to MAIN would be the entire branch. Do you reuse the development branch xx for the next feature or leave it as a dead branch? You can assume that we will\r\n need 2 or 3 development branches for future releases.</p>\r\n<p>Let&rsquo;s say that you have 6 features for Vnext &#43;1 currently in development branch 01. &nbsp;Feature 5 gets delayed.&nbsp;&nbsp; Do you roll feature 5 changes out of development branch 01 and merge with development branch 02 (Vnext &#43;2). Then merge the\r\n entire Development branch 01 to Main?</p>\r\n<p>One more question on supporting the production code.&nbsp;&nbsp; In the Advanced Branch plan, I have my hot fix branch where I make any urgent changes.&nbsp;&nbsp; I am not quite clear on how I build these changes to prod. &nbsp;Do you build fixes from the\r\n hot fix branch and overlay those files in the production environment? Some months could require 2 or 3 hot fixes and associated deployments to production. What code do I pull to recreate the&nbsp;current production code&nbsp;(release &#43; service paks(s) &#43; hot\r\n fixes).</p>\r\n<p>Thanks much,</p>\r\n<p>Tod</p>\r\n",
    "PostedDate": "2010-11-22T14:56:50.43-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "526115",
    "ThreadId": "235125",
    "Html": "\r\n<p>Tod,</p>\r\n<p>It seems to me you would be better off having a separate development branch for each version you are working on. This offers several advantages over the alternative of promoting (merging) to main by project/work item.</p>\r\n<ul>\r\n<li>One problem with cherry picking changes by work item is that is too easy to pick up partial changes. For example, if a developer makes a change in v&#43;1 to a particular class (file). Then later makes a change to fix a bug, and finally makes another change\r\n to fix a bug. You need to be sure you merge all of these related changesets to Main or you will potentially be merging buggy code to Main.\r\n</li><li>What happens if the developer forgets to associate one of these changesets to the correct project / work item? This changeset might not get merged.\r\n</li><li>If all of your developers are working in the same branch but are working on different releases, how do you avoid conflicting changes. For example, suppose you have an interface change that must be implemented for v&#43;2. If that change is made in the same\r\n branch with code for V&#43;1, you will introduce a nightmare situation. This is a major reason for feature team isolation in development (or for branching development for release). As an aside, you may hear some people talk about branching for release without\r\n being clear about whether they are branching for release development or for release to production. In this case I am referring to having separate development branches per release (v&#43;1 and v&#43;2) as well as separate release branches when the time comes to ship.\r\n</li><li>With cherry picking you run the risk of picking too many or too few changesets to merge. This introduces instability in the target branch. You also have situations where a cherry picked change gets merged again on top of code that has moved past that point.\r\n</li></ul>\r\n<p>By having separate branches for release and perhaps for features within a release you are better able to accomodate changes to the schedule (such as where feature 5 is not ready when the other features for a release are). It seems it might be quite challenging\r\n to identify all of the changesets associated with feature 5 and excluding them from a merge.</p>\r\n<p>With respect to hot fixes.. this is one of the more challenging questions to answer. When a company is shipping a product ot multiple customers the situation becomes more complicated than when you only have one version in production (such as where you are\r\n the customer of your software).</p>\r\n<p>Let's suggest that you ship V1.0 to ten customers. The release branch for v1.0 (read-only) is a snapshot of what was initially shipped to those ten customers. Typically, however, when you do hot fixes you are shipping a patch to fix a specific problem for\r\n a specific customer. So you create a hotfix for one customer. Later you create a different hotfix for a different customer. You now have three different *versions* of your code running. You might consider creating a new hotfix branch for each new hot fix or,\r\n in the case of where you are your only customer, you could consider reusing the hotfix branch. In this scenario the hotfix branch contains all of the hot fixes and would be the latest version of your production code.</p>\r\n<p>It is challenging to answer the question of *how do I build a hotfix*. Typically hot fixes are deployed as patches (MSUs or individual DLLs that have changed) rather than full installs (MSIs). Given all the variables at play I am not sure how to best advise\r\n you here.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger</p>\r\n",
    "PostedDate": "2010-11-23T14:26:10.153-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]