[
  {
    "Id": "546892",
    "ThreadId": "241188",
    "Html": "\r\n<p><span>After a few years hiatus, i am returning to the world of *published author*. My next article will be published in the February 2011 issue of MSDN Magazine (<a rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/magazine/default.aspx\" target=\"_blank\"><span>http://msdn.microsoft.com/en-u</span>s/magazine/default.aspx</a>\r\n ) The topic will be *Visual Studio ALM Rangers Branching Guidance for Team Foundation Server (TFS) Team Projects*. My co-author is Willy-Peter Schaub, also on the VS ALM Ranger team at Microsoft.</span></p>\r\n<p><span>I am also blogging on this topic: <a href=\"http://blogs.msdn.com/b/billheys/\">\r\nhttp://blogs.msdn.com/b/billheys/</a></span></p>\r\n<p><span>Feel free to post questions here on new topics you would like to see added to the next release of the Rangers's Branching Guidance. You may also post comments on my blog.</span></p>\r\n<p><span>Bill Heys<br>\r\nVS ALM Ranger<br>\r\n<a href=\"http://blogs.msdn.com/b/billheys/\">http://blogs.msdn.com/b/billheys/</a><br>\r\n</span></p>\r\n",
    "PostedDate": "2011-01-10T11:42:46.22-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "547669",
    "ThreadId": "241188",
    "Html": "\r\n<p>Looking forward to your article in MSDN, Bill.</p>\r\n<p>I was reading tech crunch today and saw this article :</p>\r\n<div><a title=\"How Google Speeds Up The Chrome Release Cycle&nbsp;(Slideshow)\" rel=\"bookmark\" href=\"http://techcrunch.com/2011/01/11/google-chrome-release-cycle-slideshow/\">How Google Speeds Up The Chrome Release Cycle&nbsp;(Slideshow)</a></div>\r\n<div>The main part of the article that interests me is the following:</div>\r\n<div>\r\n<p>&quot;Anthony LaForge, the technical program manager at Google overseeing Chrome development,\r\n<a href=\"http://groups.google.com/a/chromium.org/group/chromium-dev/browse_thread/thread/77f1de21998ee278?pli=1\">\r\ncreated</a> the presentation below (and posted it on <a href=\"https://docs.google.com/present/view?id=dg63dpc6_4d7vkk6ch&pli=1\">\r\nGoogle Docs)</a> to explain how Chrome&rsquo;s development cycles work. Instead of a traditional software development cycle where features are crammed into each release or delay the release, Chrome puts out a new release no matter what every six weeks. If new\r\n features aren&rsquo;t ready, they wait for the next release, just like waiting for the next scheduled train at Grand Central.</p>\r\n<p>Another thing that speeds things along is that the Chrome browser is <span style=\"text-decoration:underline\">\r\n<strong>simultaneously </strong></span>developed along three different &ldquo;channels&rdquo; (dev, beta, and stable). Users can pick which one they are most comfortable with, and their browsers are updated automatically. New features are introduced first in\r\n the dev and beta channels, which merge with the stable channel as those features get patched and stabilized.</p>\r\n<p>The versions start to blend together. The approach is more like updating a website than a piece of client software. The version numbers don&rsquo;t really matter. What version of Amazon are you on? Exactly.&quot;</p>\r\n<p>This model seems at odds with the branching guidance from the rangers....BUT Google ships this browser to Hundreds of MILLIONS of customers so it HAS to work. I'd love to get the rangers insight into how Google's model could be applied to TFS....we do enterprise\r\n click once development so our updates get pushed out to our&nbsp;employees rapidly and while branching has streamlined our &quot;release&quot; process, I'm&nbsp;very interested (as is my&nbsp;entire executive chain up to the CIO)&nbsp;about alternative models that produce\r\n and deliver software/value faster, better, and cheaper.</p>\r\n<p>Looking forward to your article and your thoughts.</p>\r\n<p>I found this one quote on the slides to make my head spin &quot;<strong>The Branch point is the end of our development cycle</strong>.&quot;&nbsp;\r\n<em>huh?!?!?</em></p>\r\n<p>In the TFS world isn't the guidance from the rangers that the branch point (whether by feature, by team, etc) is at the beginning of the development cycle?</p>\r\n<p>Oh and just because Chrome isn't developed by Microsoft...please don't fall into the [NIH - Not invented Here syndrome], could google's brillant engineers have come up with some new fangled better branching model?</p>\r\n<p>I've been thinking about this a little bit more and we know that Google is using Perforce...could Google be RELYing on how Perforce handles Baseless merging to accomplish this feat of simultaneous development across multiple branches without regressions?\r\n My branching spider senses are tingling that somehow Google's figured out how to&nbsp;exploit Baseless merges for good&nbsp;instead of evil....&nbsp;</p>\r\n</div>\r\n",
    "PostedDate": "2011-01-11T16:16:24.54-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "547712",
    "ThreadId": "241188",
    "Html": "\r\n<p>Thanks Allen.</p>\r\n<p>&nbsp;You won't get a NIH response from me here. We all can learn from competition. My hope (and experience) &nbsp;is that the VS ALM Ranger Branching Guidance, while written for the TFS audience is useful for users of other Source Code Managment (SCM) tools.\r\n I am at a bit of a disadvantage as to the Google deployment model, so I need to do a bit of research. I have been intending to blog on concepts similar to this. It is, I believe, simply a combination of branching flexibility (complexity) and release (deployment)\r\n flexibility. Look for a blog soon, which I will link from this thread.</p>\r\n<p>Regards,</p>\r\n<p>Bill Heys<br>\r\nVS ALM Ranger<br>\r\n<span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://blogs.msdn.com/billheys\"><span style=\"color:#6bbd46\">http://blogs.msdn.com/billheys</span></a>&nbsp;<br>\r\n<span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://tfsbranchingguideiii.codeplex.com/\"><span style=\"color:#6bbd46\">http://tfsbranchingguideiii.codeplex.com/</span></a>&nbsp;\r\n</span></span></p>\r\n<p><span style=\"color:#6bbd46; font-size:10pt\"><span style=\"color:#6bbd46; font-size:10pt\">&nbsp;</span></span></p>\r\n",
    "PostedDate": "2011-01-11T19:01:15.957-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "548281",
    "ThreadId": "241188",
    "Html": "\r\n<p>Thanks for Responding Bill.<br>\r\nWe've been looking at this for awhile and flexiblity in deployment and rapid deployment seems to be a key of large scale successful internet companies. Take flickr for example, at<a title=\" http://code.flickr.com\" href=\" http://code.flickr.com\"> http://code.flickr.com</a>&nbsp;and\r\n on the bottom you'll see another example of rapid deployment.&nbsp;</p>\r\n<p><img src=\"http://i.imgur.com/EuQ8G.jpg\" alt=\"\"></p>\r\n<p>I'd love to learn more about how to manage rapid deployments (even&nbsp;simultaneous&nbsp;deployments of concurent code lines) using TFS branching.</p>\r\n",
    "PostedDate": "2011-01-12T14:14:00.143-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "548295",
    "ThreadId": "241188",
    "Html": "\r\n<p>Allen,</p>\r\n<p>As I think about your first comment (Google Chrome Release) it seems that there are two concepts here:</p>\r\n<ul>\r\n<li>Development Process </li><li>Release Process </li></ul>\r\n<p>It seems Google Chrome uses a modified interative, incremental (Agile) process for development. They have decided that each increment will be an overlapping eleven-week iteration (the first six weeks being development). Within that eleven-week timeframe\r\n they add new functionality (features), perhaps fix bugs, test, and release an increment of working features.</p>\r\n<p>That process could easily be mapped to Scrum. Martin Hinselwood has done an interesting blog on branching for Scrum:\r\n<a href=\"http://geekswithblogs.net/hinshelm/archive/2010/04/14/guidance-a-branching-strategy-for-scrum-teams.aspx\">\r\nhttp://geekswithblogs.net/hinshelm/archive/2010/04/14/guidance-a-branching-strategy-for-scrum-teams.aspx</a>. You will note that I had the opportunity to review this blog before it was published. It draws heavily from the Rangers Branching Guidance.</p>\r\n<p>If you are familiar with Scrum, you probably know that you need to start with a set of features to develop (the Product Backlog). This is prioritzed and as many of the top-priority features as can be developed and shipped in one Sprint are then moved onto\r\n the Sprint Backlog (during the Sprint Planning Session). Sprints are often 30-days in duration, but some are as short as two weeks, while some may go longer. You could, I argue, suggest that the Google Chrome development takes place as 6-week Sprints (after\r\n a fashion).</p>\r\n<p>You will often see the activities of a Sprint depicted as a circle - to show the iterative nature of Scrum software development. It starts with a Sprint planning meeting, where the Sprint backlog is agreed to. It proceeds unhindered by the stakeholders,\r\n until the Sprint backlog is developed and ready to ship. This is followed by a Sprint retrospective, that takes a look back at what went well, and what did not go well. Following this, the next Sprint begins. If you wanted to look at this on a timeline, you\r\n could *unwind* the circle and lay it on a straight timeline. The length of this timeline would correspond to the length you have chosen for a Sprint (typically 30-days)</p>\r\n<p>From a branching perspective, there are two schools of thought. One - create a single Development branch as a full child of Main - which is where the Sprint Team works on development during a Sprint. At the end of the testing, this branch is merged back\r\n down to Main (RI) to be stabilized for release. If you look at Martin's blog, you will see that the timeframe for a Sprint begins with the Sprint planning meeting. Most of the activities during the Sprint take place on the Development (Sprint) branch. But\r\n the Sprint does not end when the Development (Sprint) branch is merged to Main. It ends when the Main branch is tested (stabilized) and then branched for Release. You would have one release branch per Sprint.</p>\r\n<p>The second school of thought is the same as the first, EXCEPT you would have a new Development (Sprint) branch created each time a new Sprint begins. I happen to prefer the first approach (a Sprint branch that simply continues from one Sprint to another).\r\n Martin makes the point that by having a single Sprint branch, you have continuous history for that branch.</p>\r\n<p>The Sprint Branches in this example would correspond to the Dev branch in the Google Chrome presentation. The Main branch, as it is being stabilized, would correspond to the Beta branch in the Google Chrome presentation. Finally the Release branch would\r\n correspond to the Stable Release branch in the Google Chrome Presentation.</p>\r\n<p>Next we come to deployment.</p>\r\n<p>I have always viewed support for multiple environments such as Feature Testing, Integration Testing, System Testing, User Acceptance Testing to be deployment issues, not branching issues. By that I mean that I don't necessarily have a need to build a QA\r\n branch in order allow my QA team to test the code in mhy Feature branch. I deploy the code from the Feature branch to the QA environment. I can control how often and when I do this deployment. In this way I can also associate bugs from QA with the specific\r\n deployment (which might be labeled in the associated branch).</p>\r\n<p>So, back to the Google Chrome scenario. They talk about the concept of *channels*. Channels, to me are deployment options. Here, Google allows customers to subscribe to one of three channels: Dev, Beta, or Release. All this means, in my view is that you\r\n have three Drop locations which customers can subscribe to. A Dev drop location, a Beta drop location, and a Release drop location. When Google *drops* a new deployment into one of these drop locations, your subscription to update from the corresponding channel\r\n will bring these changes to your environment.</p>\r\n<p>What is different here from a typical environment? They allow you to subscribe to features in Development *before* they have been Beta tested. Or to features in Beta test *before* they are ready for Release. Presumably there is increased risk and less stability\r\n when you subscribe to the Beta channel and even more risk and less stability when you subscribe to the Dev channel. This does not, in my view, mean you would do a daily drop from Dev into the Dev Drop location and make it available to the subscribers to the\r\n Dev channel. What it does mean is that roughly six weeks after a dev cycle begins, when the code is branched to Beta, the Dev code can be dropped into the Dev channel. Then after the code in Beta has been tested, perhaps it is dropped weekly into the Beta\r\n channel. Finally when the code is ready for release, it is branched for Release and dropped into the Release channel.</p>\r\n<p>The key is code must be feature complete and tested in the Dev channel, while it can be incrementally dropped on a weekly basis from the Beta channel, and then dropped into the Release channel. The full timeline for a Google Release is approximately eleven\r\n weeks (six in Dev, and five in Beta). It is agile, but takes place on a longer cycle than typical Scrum projects.</p>\r\n<p>I will take a look at Flickr to see how it influences my thinking next.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger<br>\r\n<span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://blogs.msdn.com/billheys\"><span style=\"color:#6bbd46\">http://blogs.msdn.com/billheys</span></a>&nbsp;<br>\r\n<span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://tfsbranchingguideiii.codeplex.com/\"><span style=\"color:#6bbd46\">http://tfsbranchingguideiii.codeplex.com/</span></a>&nbsp;\r\n</span></span></p>\r\n<p><span style=\"color:#6bbd46; font-size:10pt\"><span style=\"color:#6bbd46; font-size:10pt\">&nbsp;</span></span></p>\r\n",
    "PostedDate": "2011-01-12T14:49:30.63-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "550686",
    "ThreadId": "241188",
    "Html": "\r\n<p>Bill - I found another interesting article about how facebook ships code. It might make great reference material for the next rev of the branching guidance.\r\n<a href=\"http://framethink.wordpress.com/2011/01/17/how-facebook-ships-code/\">http://framethink.wordpress.com/2011/01/17/how-facebook-ships-code/</a></p>\r\n<p>I thought these&nbsp;4 sections were very interesting:</p>\r\n<li>no QA at all, zero. &nbsp;engineers responsible for testing, bug fixes, and post-launch maintenance of their own work. &nbsp;there are some unit-testing and integration-testing frameworks available, but only sporadically used.\r\n</li><li>re: surprise at lack of QA or automated unit tests &mdash; &ldquo;most engineers are capable of writing bug-free code. &nbsp;it&rsquo;s just that they don&rsquo;t have an incentive to do so at most companies. &nbsp;when there&rsquo;s a QA department, it&rsquo;s\r\n easy to just throw it over to them to find the errors.&rdquo; </li><li>by default <span style=\"text-decoration:underline\"><strong>all</strong></span> code commits get packaged into weekly releases (tuesdays)\r\n</li><li>getting svn-blamed, publicly shamed, or slipping projects too often will result in an engineer getting fired. &nbsp;&rdquo;it&rsquo;s a very high performance culture&rdquo;. &nbsp;people that aren&rsquo;t productive or aren&rsquo;t super talented really\r\n stick out. &nbsp;Managers will literally take poor performers aside within 6 months of hiring and say &ldquo;this just isn&rsquo;t working out, you&rsquo;re not a good culture fit&rdquo;. &nbsp;this actually applies at every level of the company, even C-level\r\n and VP-level hires have been quickly dismissed if they aren&rsquo;t super productive.</li>",
    "PostedDate": "2011-01-17T11:07:44.127-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "550697",
    "ThreadId": "241188",
    "Html": "\r\n<p>Allen,</p>\r\n<p>Interesting article, but there is not much here that directly pertains to branching.</p>\r\n<p>They are doing weekly releases, but the concept is similar to the blog I just published (the primary differences being the number of engineering teams working in parallel and the frequency of releases)</p>\r\n<p>There is not a lot of insight in this article (or the Flickr article) as to how branching supports their development / release process.</p>\r\n<p>Clearly Facebook, by design, is an intimidating engineering environment. They rely on individual excellence for their success, rather than formal processes. They will find this model increasingly difficult as they grow. Microsoft is at least 50x the size\r\n of Facebook. At some point you cannot manage 100,000 employees by expecting them all to be individually responsible for writing perfect (bug-free) code. In fact I find the very concept to be arrogant and naive. Most engineers simply do not understand how to\r\n test, nor do they have the desire to do so. Engineers, at least those I have worked with, much prefer building something over finding bugs in what they build. When engineers test, they often focus on proving something works, rather than proving where it does\r\n not work. For example, do a check-out for a shopping cart, and you get a confirmation screen for your order. But did it log all of the correct information, what happens if you enter a negative quantity into a line item. Does the system consolidate multiple\r\n line items *of the same thing* into one line item on the order (by incrementing quantity), how does it handle dates in the past, etc.</p>\r\n<p>QA departments, by contrast, are motivated to find the things that don't work, and they are perhaps less interested in finding the things that do work. Engineers have already tested that perspective.</p>\r\n<p>This article, therefore, offers more insight into the (alleged) culture at Facebook, the lack of a formal QA process (not a branching discussion), weekly releases (more of a deployment discussion), lack of automated testing (a silly, and arrogant excuse\r\n for not having proper regression testing processes in place), etc.</p>\r\n<p>The one concept that I do think has implications for branching is the (*all code commits* get packaged into a release - the concept of releasing the latest version rather than cherry picking changes for release is fundamentally part of our guidance.</p>\r\n<p>Regards,</p>\r\n<p>Bill Heys<br>\r\nVS ALM Ranger</p>\r\n<p><span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://blogs.msdn.com/billheys\"><span style=\"color:#6bbd46\">http://blogs.msdn.com/billheys</span></a>&nbsp;<br>\r\n<span style=\"color:#6bbd46; font-size:10pt\"><a href=\"http://tfsbranchingguideiii.codeplex.com/\"><span style=\"color:#6bbd46\">http://tfsbranchingguideiii.codeplex.com/</span></a>&nbsp;\r\n</span></span></p>\r\n<p><span style=\"color:#6bbd46; font-size:10pt\"><span style=\"color:#6bbd46; font-size:10pt\">&nbsp;</span></span></p>\r\n",
    "PostedDate": "2011-01-17T11:29:07.827-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "620487",
    "ThreadId": "241188",
    "Html": "<p>Bill, I saw a really interesting presentation on facebook on their branching structure and pushes: <a href=\"http://techcrunch.com/2011/05/30/facebook-source-code/\">http://techcrunch.com/2011/05/30/facebook-source-code/</a></p>\n<p>I was surprised that they have such a simplified branching model. I'm also surprised they are using GIT, SVN, and Perforce....and not TFS. I'd love to learn more why they aren't using TFS...given their close relationship with Microsoft ($100 Million dollars).</p>\n<p>Allen</p>",
    "PostedDate": "2011-05-30T16:03:49.88-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "620524",
    "ThreadId": "241188",
    "Html": "<p>Thanks for this Allen.<br />I am working with a customer that seems to be working under similar constraints. Frequent releases, rapidly growing engineering team. <br />This customer has been using Subversion, but they want to move to TFS to take advantage of the dashboard capabilities. They need to be more transparent with respect to reporting status to their senior managment and stake holders. <br />Interestingly, they don't use branching *at all*. They have one *trunk* in Subversion. When they want to do a release, each developer *checks-in* their changes to the trunk (sounds like FB).</p>\r\n<p>I would observe that the FB branching structure maps *somewhat* to the Basic branch plan. Their *Trunk* is what we call the development branch. It is where developers check-in their code. Our main branch is where FB does their stabilization and release, etc.</p>\r\n<p>Bill</p>",
    "PostedDate": "2011-05-30T18:59:48.807-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]