[
  {
    "Id": "707792",
    "ThreadId": "281898",
    "Html": "<p>I am trying to move a number of old projects from VSS to TFS.&nbsp; These are Java/Maven/Sonar efforts.&nbsp; I have moved several successfully and the developers now get continuous integration at checkin time as well as weekly SW analytics from Sonar (complexity, redundancy, tangle, etc.).&nbsp; The issue is that one or two VSS projects rely heavily on \"delta branches\".&nbsp; These projects each have a primary development branch, but, largely to accomodate customer specific changes (not suitable for common approaches to skinning or Spring), these projects each have a set of (sparse) delta branches each of which contains just the files touched to produce the&nbsp;customizations needed for a single customer delivery.&nbsp; At build time, all files are taken from the appropriate (VSS)&nbsp;label in the primary development branch and then those files are overwritten by the files in&nbsp;the&nbsp;appropriate delta branch ... and then a build is initiated.&nbsp; I am not wild about this practice, but one of the projects has over a hundred and forty such delta branches and I have to find a way to either accommodate a similar scheme in TFS or plan a transition to&nbsp;an alternative&nbsp;strategy.</p>\n<p>Any suggestions?</p>",
    "PostedDate": "2011-12-05T13:59:53.303-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "707842",
    "ThreadId": "281898",
    "Html": "<p>Let me clarify the underlying requirements for these one or two troublesome projects.</p>\n<ul>\n<li>Can you describe the type of application architecture? Is it an internal website? Is it a standalone windows app that runs on a desktop or a client-server windows ? I know that sounds irrelevant, but it will help us understand just in case it reveals some nuance. </li>\n<li>You said these projects each have a main dev branch, so in terms of requirements, your team works on one release at a time, together, right? They develop and checkin directly to that dev branch.&nbsp; </li>\n<li>Is there a trunk that the dev branch is split off of or is their \"dev\" branch really the main trunk line? If the dev branch is separate, by what rule and how often do you merge dev to main? </li>\n<li>How many customers have unique variations? 2? 20? 200?&nbsp; </li>\n<li>Those hundred and forty delta branches, let me understand clearly. They are short-lived and represent different builds right? These are not long-lived development branches for one hundred forty customers? (hence my previous question). </li>\n<li>I assume that you want the main bulk of work done in the dev branch, and readily available to ALL customers. This means even the special customers get the benefits of the main line development effort. </li>\n<li>How often do you deliver the standard version of the product? </li>\n<li>How often do you deliver the specialized versions of the product? </li>\n</ul>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>",
    "PostedDate": "2011-12-05T16:42:42.517-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708414",
    "ThreadId": "281898",
    "Html": "<p>The most interesting case is a project with about 70 customer \"sites\".&nbsp; This is an advertising offering that provides a variety of retailers the ability to put up ads and promotions (w/flash, etc).&nbsp; Currently there is a primary development source \"branch\" that has been around for many years.&nbsp; At various times, new advertisers (our customers) are acquired.&nbsp; Each time there is a new customer acquisition, a \"delta branch\" is created.&nbsp; This branch will hold skinning materials as well as some customized java (but the delta branch will only hold the artifacts from the primary development branch that must be touched to satisfy a given customer's special needs).</p>\n<p>Developers are always working against the primary development branch (overlayed by the appropriate delta branch).&nbsp; There is only one development branch and no \"mainline\".&nbsp; Picture a single long development branch with a delta branch spur for each deployment.&nbsp; Upgrades involve copying spurs to a more recent part of the primary development branch and reconciling customer specific artifacts with the newer portion of the primary branch.</p>\n<p>Each (and every) customer (roughly 70 at the present time) has unique artifacts maintained in a dedicated delta branch.</p>\n<p>The delta branches are long lived.&nbsp; The current state of each customer is represented by a label on the primary development branch plus a delta branch.</p>\n<p>Most features are supported by the primary development branch.&nbsp; Customer specific features (and \"skinning\") are supported by the delta branch.</p>\n<p>Every customer has a delta branch because, at the very least, there is always skinning to be done.&nbsp; The \"standard\" version of the product is never delivered.&nbsp; A specialized version is always delivered.</p>\n<p>I realize that skinning can be done in other ways and that features can be made configurable.&nbsp; The reality here is that there are so many unique requests that making everything configurable would mean that a great many features would only be configured \"on\" for a single customer.&nbsp; Burdening the primary development branch with all these minor, \"one-shot\" variations would vastly complicate and obfuscate the primary development branch...</p>",
    "PostedDate": "2011-12-06T13:28:36.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708446",
    "ThreadId": "281898",
    "Html": "<p>Here are some design ideas to try.</p>\r\n<p>Option 1&nbsp; - Keep doing what you are doing. TFS version control can support that just as well as VSS did. Why change if you are happy with your model?</p>\r\n<p>If you are unhappy with your current design, keep reading.</p>\r\n<p>Option 2 - Keep your main branch, against which you develop enhancements, and simply make 70 branches directly off of it, that are full branches of the entire main branch. No need for sparse branches.&nbsp; TFS does not needlessly make duplicate files on the server. You won't have 70xProject size on the server.&nbsp; Then update each branch with its unique artifacts, checkin, and you are done setting up your new structure. Do builds for each customer from their branch.&nbsp; Whenever a customer&nbsp;is ready to take a newer version, forward integrate (merge from Main to Customer branch). In this model, you will never reverse integrate (merge from Customer to Main) because customers changes don't belong in the common product.&nbsp;&nbsp;Regarding disk space requirements, the server may be smart, but the clients are not so much.&nbsp;Meaning,&nbsp;if a developer were to download all 70 branches, they WOULD have 70 x Project files. But why do that? A dev can get latest only on a project that needs changing. They can update it with skinning changes, or merge enhancements in, test them, and check them in.&nbsp; And can be deleted from their local drive when they don't need it.</p>\r\n<p>One variation to consider for either option is to setup a single Development branch off of the main branch. Using my terminology, you are currently checking into the Main branch as part of your development process. With your current approach, do you ever find that developers are in the middle of making changes, and the main branch is not ready and fully working, but&nbsp; a customer needed to get the latest stable build, but you could not give it to them cause it's in transition?&nbsp; If not, then you are fine. If you have experienced this friction, then you would enjoy having one development branch. Developers can do their jobs in there without regard for stability.&nbsp; And if a customer needs the latest stable stuff, a developer can merge from Main to the Customer branch, since Main does not get polluted with work in progress. Then you can update Main every time your Development branch has something safe and stable and deployable.&nbsp; In an ideal development process, every checkin is safe, stable and deployable. But I know in real life, sometimes people make changes that break the product while those changes are in transition.&nbsp; That is why I recommend a separate development branch.</p>\r\n<p>Let me know what you decide to do and why. I'm interested to learn from your situation.</p>",
    "PostedDate": "2011-12-06T14:25:54.91-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708491",
    "ThreadId": "281898",
    "Html": "<p>First, many, many thanks for your input.&nbsp; It is good to find an active TFS community.&nbsp; Going it alone gets boring.</p>\n<p>Option 1: The main problem is that TFS provides no built-in \"delta branch\" functionality that I know of.&nbsp;&nbsp; (Feel free to educate me. I would love to find that delta branches&nbsp;are supported by&nbsp;TFS.)&nbsp; And you cannot have two TFS repositories point at the same workarea folder.&nbsp; (Which is what was done with VSS.)&nbsp; This makes it hard to \"overlay\" a delta branch on a primary branch.&nbsp;&nbsp; And we would want to do that to support developer workstation builds in Eclipse and provide the sort of immediate feedback developers get now when they edit a file (or generate a quick&nbsp;war file to test the app with the Tomcat that is embedded in Eclipse).&nbsp; Also, if I am to make the delta branch work with TFS continuous builds, I would have to push past the XAML to the MSBuild XML to insert an overlay action between getting the source and compiling it.&nbsp; This may be possible, but I hate complicated solutions.</p>\n<p>Option 2:&nbsp; I have been arguing for something like this.&nbsp; The developers come back with the concern that when they upgrade they will not know exactly what was customized.&nbsp; Now they merge a top-of-tree primary development branch with an old delta branch&nbsp;and they know exactly what was customized.&nbsp; The customizations are exactly what was in the delta branch.&nbsp; If they merge a primary development branch with a <em>complete </em>customer branch, they will not know which conflicts are simple upgrades of primary functionality and which are customizations.&nbsp; They will&nbsp;risk losing customizations because they won't have an inventory of what they were. &nbsp;This, they say, will introduce signifcantly greater labor costs and more errors.</p>\n<p>Regarding the variation, I agree that it would be worth considering.&nbsp; There are certainly&nbsp;times when more than one customer is being worked on, but I think I should get past the issue in the previous paragraph before I suggest both a \"ready to ship mainline\" and a primary development branch.</p>",
    "PostedDate": "2011-12-06T15:51:55.38-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708538",
    "ThreadId": "281898",
    "Html": "<p>You're welcome. I feel the same way.</p>\r\n<p>Which version of TFS are you using?</p>\r\n<p>I don't understand what a delta branch is.&nbsp; I do know that you can branch at as low a level as you like. Although I normally branch at a very high level (for good reasons), you can branch particular folders at any level. Let's say you had CSS customizations in a folder named CONTENT or something like that.&nbsp;You could make branches for just that folder and name them after the customer.&nbsp; Then you can play the same game you play today (I think).&nbsp;&nbsp;This way, you get&nbsp;70 sparse branches, with perhaps&nbsp;a few folders out of the total.&nbsp; &nbsp;But with your current approach, how do your developers easily test a particular customer's work? Don't they have to get the main line then overlay to test?</p>\r\n<p>About option 2 and the objection. There is a great answer to that. You see, when you merge changes from the main branch to the customer branch, it does not just DO it and step on anything that happened in the customer branch.&nbsp;It will make the changes in your local workspace, and checkout all the files that were changed.&nbsp; Then the person doing the merging must examine any files that were checked out. Presumably your folks know what files should be left alone. If the main development team altered skinning files, then the developer doing the merge can choose to keep the customer version of those files&nbsp;and disregard the enhancement. Though one would want to explore the implications of ignoring a mainline change. But if the main team is not changing skinning files, then you won't even see anything to worry about&nbsp;on the merge.&nbsp; And with this model, any developer can easily open up a customer's branch and run it to immediately see how it looks, without piecing stuff together.&nbsp; It just feels much easier to me.</p>\r\n<p>I recommend you create a new TFS project as a sandbox unless you already have one. Then setup some experiments and try out the options I listed or make up your own.&nbsp; Practice branching and merging and see how it works for yourself.&nbsp; A sandbox is a wonderful learning too.&nbsp; It will be totally isolated and won't hurt anyone.&nbsp; If you are new to TFS version control, and don't feel you know how to experiment with this, &nbsp;I recommend you hire a partner who knows branching with TFS to come in for a few hours and play thru some scenarios, perhaps starting with the ones we discussed. If you need a reference to a partner in your area,&nbsp;you can contact Microsoft or just tell us what city you work in and someone will be glad to offer a suggestion.</p>",
    "PostedDate": "2011-12-06T19:16:05.663-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708540",
    "ThreadId": "281898",
    "Html": "<p>David,</p>\r\n<p>Thanks for you answers on this forum. They are insightful and helpful.</p>\r\n<p>Regards,</p>\r\n<p>Bill Heys<br />VS ALM Ranger</p>",
    "PostedDate": "2011-12-06T19:19:39.89-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708546",
    "ThreadId": "281898",
    "Html": "<p>Thanks for the kind words, Bill.</p>\r\n<p>Oh, and ajenny, I forgot to ask whether your team uses Team Explorer Everywhere. &nbsp;I heard about it at the recent ALM Summit. It's apparently a tool&nbsp;that&nbsp;includes plugis&nbsp;for people who use other IDEs like Eclipse on other platforms like Mac and Linux and several others.&nbsp; I mention it because having good tooling can make the experience much more pleasant for the developers.</p>\r\n<p>David Kreth Allen<br />Consultant</p>",
    "PostedDate": "2011-12-06T19:51:58.237-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708871",
    "ThreadId": "281898",
    "Html": "<p>To answer your questions:&nbsp;&nbsp; We are using TFS 2010, Eclipse 8 and 9 (for Spring) w/ TEE.&nbsp; I do have a sandbox and I have been experimenting with TFS branching.&nbsp;</p>\n<p>A delta branch is a collection of some (but not nearly all) of the files in the primary development branch source tree.&nbsp; Files in the delta branch are organized into the same folder structure as the primary development branch, but most of the files in the primary development branch are not included in the delta branch.&nbsp; Just the files that had to be changed for a specific customer delivery are included in the delta branch.&nbsp; The changed files&nbsp;can be from anywhere in the primary development branch tree.&nbsp; They are not located in a single folder nor are they always the same set of files.&nbsp; Anything can be touched.</p>\n<p>Regarding the folder and/or file level branching:&nbsp; This sounds interesting, but to use it for one of the delta branches described above, I would have to be able to pick multiple files and/or folders from anywhere in the primary development branch tree and include them all in a single branch.&nbsp; Can I do this?&nbsp; Or, when we branch at the folder and/or file level, is each folder and/or file branched a separate branch?&nbsp; Also, if I am able to create a delta branch, is there a way to use it in combination with a primary branch at build time (without digging into the MSBuild XML)?</p>\n<p>Regarding the manual merging:&nbsp; I think efficiency would more-or-less depend on having the person that did the original work do the merging (and do it while details were still easily remembered).&nbsp; That is not always possible.&nbsp; People move on to other jobs and (believe it or not) some of our customers wait years before they press for updated primary functionality and/or new customizations.&nbsp; The delta branch is our&nbsp;unambiguous record of exactly what changes were made for each customer delivery.&nbsp; A labeled version of the primary development branch plus a delta branch is our unambiguous record of the entirety of the source that was used for each customer delivery.</p>",
    "PostedDate": "2011-12-07T08:31:25.72-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708902",
    "ThreadId": "281898",
    "Html": "<p>Folder level branching seems inappropriate and messy for&nbsp;what you want. Each folder branched is a separate branch.&nbsp; So I would not go down that path.</p>\r\n<p>Your observation on manual merging implied that it might be too difficult with programmer&nbsp;turnover and length of time between upgrades (merges).&nbsp; But how is it any easier with your current system? If you take a mainline code base that has evolved for two years, and take customizations made to a version that existed two years ago, and drop the customizations on top of the copy of the new mainline, I would expect a great deal of care would be required to ensure the result still works. There is no guarantee that the customizations made two years ago will work with the new mainline. Using merging tools, you get to see the conflicts, and resolve them one-at-a-time.&nbsp; Either way, the challenge, as you pointed out, has to do with the essential factor that upgrades are taken on long intervals.&nbsp; No matter what tools you use, you will need to exercise care in merging the result. Merely overwriting does not make it easier. Oh, it is easy to overwrite the new stuff with changes.&nbsp; That is quick and easy.&nbsp; But it just defers the difficulty to testing and debugging instead of examining the conflicts before you drop them into place. Or am I missing something? This upgrade scenario seems like one of the few and most complex and I want to be sure I understand it.</p>\r\n<p>In any case, here is another design to consider.&nbsp; This one does a better job of preserving each customer's changes in a form that is easy to vie and compare against.&nbsp;&nbsp;Still we have one main line of code for the core.&nbsp; Each customer gets a full branch we'll call their development branch.&nbsp; Off of that, each customer gets one Release Branch.&nbsp; So with 70 customers, you would have 70 x 2 + 1 main = 141 full branches.</p>\r\n<p>Process Rules:</p>\r\n<ol>\r\n<li>When you want to upgrade a customer, you <ol>\r\n<li>merge from main to their development branch, and overwrite anything in development to essentially make it resemble the customer's release version. Checkin everything changed in Customer development. Now development looks like their release (what they have today).</li>\r\n<li>merge main to customer's development branch.&nbsp; Test the software, and reconcile any changes required.&nbsp; Check in as needed. Then when you consider it \"done\", you can merge this backup up to the customer's release branch and package and deploy from there.&nbsp; Or for a variation, you could make another branch off their development branch for each release. That would be a way to preserve previous releases for easy view and comparison.</li>\r\n</ol></li>\r\n<li>You never merge from a customer development branch to main.</li>\r\n</ol>\r\n<p>Let me see if I can summarize your requirements, now that we've discussed for a bit and they have emerged:</p>\r\n<ul>\r\n<li>You have lots of customers.</li>\r\n<li>Each has their own variation on the software.&nbsp; </li>\r\n<li>You need to be able to upgrade any one of them to take changes in a main branch.</li>\r\n<li>Upgrades may happen infrequently.&nbsp; They may wait one, two , or more years before they ask for an upgrade.</li>\r\n<li>You make changes to the core with a frequency of ____ (we did not talk about that yet).</li>\r\n<li>You must be able to grab what they have at any point and view or change it if needed. And you need to easily test the result.</li>\r\n</ul>\r\n<p>Are there any other requirements that have emerged so far?</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-12-07T09:40:44.113-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708918",
    "ThreadId": "281898",
    "Html": "<p>Your requirements look good.&nbsp; Upgrades to core happen once or twice a year.</p>\n<p>Your suggestion looks interesting, but I'm not sure I understand your process rules.&nbsp; Both 1.1 and 1.2 are merges from main to a customer development branch?&nbsp; Also,&nbsp; if customer development happens in the development branch, won't the customer development branch and the customer release branch be the same (less any late breaking bug fixes)?&nbsp; Or is the customer development branch the version of core that was used to start the customer specific work and the release branch the place that that the customer specific work was done?&nbsp; Please clarify.&nbsp; We may be on the right track here.</p>\n<p>You say</p>\n<p><em>Process Rules:</em></p>\n<ol>\n<li><em>When you want to upgrade a customer, you </em><ol>\n<li><em>merge from <span style=\"color: #ff0000;\">main(?) </span>to their development branch, and overwrite anything in development to essentially make it resemble the customer's release version. Checkin everything changed in Customer development. Now development looks like their release (what they have today). </em></li>\n<li><em>merge main to customer's development branch.&nbsp; Test the software, and reconcile any changes required.&nbsp; Check in as needed. Then when you consider it \"done\", you can merge this backup up to the customer's release branch and package and deploy from there.&nbsp; Or for a variation, you could make another branch off their development branch for each release. That would be a way to preserve previous releases for easy view and comparison. </em></li>\n</ol></li>\n<li><em>You never merge from a customer development branch to main. </em></li>\n</ol>",
    "PostedDate": "2011-12-07T10:19:56.053-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "708946",
    "ThreadId": "281898",
    "Html": "<p>First, In some ways, the way in which TFS stores files when branching seems similar to your *delta branch* concept. I wrote a blog post on this a while ago (<a href=\"http://blogs.msdn.com/b/billheys/archive/2011/05/05/how-tfs-stores-files-and-calculated-deltas-on-versioned-files.aspx\">http://blogs.msdn.com/b/billheys/archive/2011/05/05/how-tfs-stores-files-and-calculated-deltas-on-versioned-files.aspx</a>).</p>\r\n<p>In essence, when you make a full child branch (branching from a parent branch), TFS does not redundantly store all of the content in both branches. Essentially the new branch contains meta data but not content for all of the files contained in the branch. Only when changes are made subsequent to the branch are copies made (or deltas) of the changed files.&nbsp;</p>\r\n<p>Second, I agree that David's Process Rules steps 1.1 and 1.2 appear redundant. I think it would be helpful to step back and draw a picture of the proposed branching structure. I might propose something like this:</p>\r\n<p>For the core product, create a branching structure that consists of a Main, Dev, and Release branches. In this way, the Core product could be released on a different cadence from the individual, specialized customer branch structures.</p>\r\n<p>Since each of the customer releases *starts* with a specific version of the core project, you might consider creating a dependency from each Customer branch plan back to the Core project branch plan. You might consider a Main/Dev/Release structure for each customer. The Main branch might be a child branch of a branch in the core project. From this Customer-Main branch, you could create a Customer-Dev branch and a Customer-Release branch. Granted this will cause, perhaps 70 sets of branches (perhaps three branches per customer).&nbsp;</p>\r\n<p>The structure might look like this:</p>\r\n<p>Core-Main</p>\r\n<p>&nbsp; &nbsp; | Core-Dev</p>\r\n<p>&nbsp; &nbsp; | Core-Release 1.0</p>\r\n<p>&nbsp; &nbsp; | Core-Release 2.0</p>\r\n<p>&nbsp; &nbsp; | Core Release 2.1</p>\r\n<p>&nbsp;</p>\r\n<p>Each Customer would have:</p>\r\n<p>Customer 001-Main</p>\r\n<p>&nbsp; &nbsp; | Customer 001 - Dev</p>\r\n<p>&nbsp; &nbsp; | Customer 001 - Release 1.0</p>\r\n<p>&nbsp; &nbsp; | Customer 001 - Release 1.1</p>\r\n<p>&nbsp; &nbsp; | Customer 001 - Release 2.0</p>\r\n<p>and son on</p>\r\n<p>Key here is understanding the relationship between the Customer branch structures (e.g. Customer 001 - Main) and the Core Branch Structures (e.g. Core - Main)</p>\r\n<p>If you want to ensure that each customer stays in sync with upgrades to the core project, you might consider creating a branching relationship where Core - Main is branched to create each of the 70 Customer - nnn - Main branches.</p>\r\n<p>Any time code for a specific customer wanted to accept updates from the Core code, it would merge Core-Main to Customer-nnn-Main</p>\r\n<p>From there, you would merge updates from Customer-nnn-Main to Customer-nnn-Dev on a frequent (daily) basis. But you would merge Customer-nnn-Dev to Customer-nnn-Main only when you reach a milestone and want to begin stabilizing a new release for the Customer.</p>\r\n<p>Once you stabilize Customer-nnn-Main you would branch it for release to Customer-nnn-Release.</p>\r\n<p>With this branch design, you have a set of main, development and release branches for core and for each customer. The main branch for core is separate from the main branch for each customer.&nbsp;</p>\r\n<p>For each version (of either core or customer), follow the basic guidance (merge daily from main to dev, merge from dev to main when it is ready to ship. Stabilize in Main, Branch main to release. Never check changes into a Main branch. Never merge from Main to Release after it is created, etc.</p>\r\n<p>Alternatively, you could consider a different relationship between customer and core. You could establish assembly references from Customer-nnn-Main to Core-Release-V1 (or v1.1 or v2.0 etc)</p>\r\n<p>When you want to upgrade a customer from v1 to v2 of Core you simply change the Customer's main branch to point a newer version of Core assemblies.</p>\r\n<p>Hope this helps,</p>\r\n<p>Regards,<br />Bill Heys<br />VS ALM Ranger&nbsp;</p>",
    "PostedDate": "2011-12-07T11:18:52.237-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "709071",
    "ThreadId": "281898",
    "Html": "<p>Your suggestion seems the right way to move from an \"overlay\" approach to a \"complete branch\" approach.&nbsp; I will present it to our developers.&nbsp; I suspect they will come back with concerns about complexity, but we shall see.</p>\n<p>Thanks to&nbsp;both of you for your generous contribution of time and interest.&nbsp;&nbsp; TFS is a great tool and I look forward to working with it.</p>",
    "PostedDate": "2011-12-07T15:53:39.267-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "709539",
    "ThreadId": "281898",
    "Html": "<p>Oops,&nbsp; I see I mis-typed it.&nbsp;&nbsp;In 1.1 I meant to say \"merge from customer's release branch to customer's development branch\" I like Bill's suggestion of drawing a picture. I design branches with pictures and I find it hard to convey without a white board.&nbsp; I'm glad Bill jumped in here. This one is complex and his knowledge of the product is much deeper than mine.</p>\r\n<p>Anyway, it sounds like you have enough raw material to think this through with your team.&nbsp; Best wishes on whatever you decide.</p>",
    "PostedDate": "2011-12-08T13:49:15.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]