[
  {
    "Id": "577416",
    "ThreadId": "248923",
    "Html": "\r\n<p>Hi All,</p>\r\n<p><br>\r\nI have a scenario I'd like some best practice advice on.</p>\r\n<p>We have a large public facing website.&nbsp; We have 3 development teams working on the website, each in their own project/feature branch, merged from a Main (or as well call it Trunk).</p>\r\n<p>This is all working well and apart from a project which does major re-organisation of the codebase the merge's are not to bad.&nbsp; We only merge from a development branch to the&nbsp;Main when that project is the next to be released to production.</p>\r\n<p>From Main we also have a Production branch, which represents what is currently in Production allowing us to perform hotfixes etc.</p>\r\n<p>The issue we have is we also have&nbsp;a UI team which make daily changes to content, javascript, css etc on the website.</p>\r\n<p>From our Production branch we have created a child branch called UI.</p>\r\n<p>The UI team work on TFS workitems and check in their code against a workitem.&nbsp; When a particular workitem is ready for production, all the files with all changesets associated with that workitem are released into production.</p>\r\n<p>The problem we have is then merging these changesets back to the Production branch.&nbsp; We fall into the scenario of cherry picking changesets and all the associated problems.&nbsp; Especially when multiple changesets linked to the same workitem have the\r\n same file.</p>\r\n<p>We cannot just select all UI branch changes and merge to production as not all of the inprogress work items actually have been released to production yet.</p>\r\n<p>Does anyone have any thoughts or suggestions on how best we should handle this scenario?</p>\r\n<p><br>\r\nThanks</p>\r\n<p>Rick</p>\r\n",
    "PostedDate": "2011-03-08T13:56:42.96-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "582347",
    "ThreadId": "248923",
    "Html": "<p>I can't give you best practice advice, but I can help move this conversation along a bit.</p>\n<p>From the description it sounds like your problem area is the UI branch contains several short/tactical changes that are ready to release to Production at different times. How would you organize this if one of your feature (product)&nbsp;branches had the same situation (overlapping release changes in the same branch)?</p>\n<p><strong>Option #1: Separate \"hotfix\" UIChangeN child branches off Production</strong></p>\n<p style=\"padding-left: 30px;\">My first thought is to move away from having a monolithic \"UI\" branch for all UI changes. If you have several concurrent UI changes in progress that overlap (or have risk of overlapping) then each should have their own branch to remain isolated until it is ready for release. This looks very similar to having multiple short-lived \"hotfix\" branches. This is a mirror of the \"<strong>Multi-Feature Teams Scenario</strong>\" (from TFSBranchingGuideIII :-)) pattern you described for your project/feature branches. Only difference is UI \"hotfix/livesite\" branches are children of Production rather than Trunk.<br /><strong>Example: </strong>If UIChange1 and UIChange2 are branches off the Production branch then UIChange1 or UIChange2 could go to production without shipping parts of the other change.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDEA: Consider naming branch after Work Item number (WI12345, etc.)<br />--ProjectA<br />--ProjectB<br />--ProjectC<br />Trunk<br />--Production<br />----UIChange1<br />----UIChange2<br />----WI12345&nbsp; (Where WI12345 is Work Item #12345)<br /><br />PRO: Support parallel development on same source files. Also it mirrors pattern your teams are already familiar with for pre-release development (and consistency is a GOOD thing).<br />CON: Build automation, Forward Integration of any changes&nbsp;(from other hotfix releases), and other branch management is multiplied by number of concurrent fixes. Also short-lived branches typically have unique names so you can't re-use the same build definitions and workspace mappings</p>\n<p style=\"padding-left: 60px;\">What if UIChange1 and UIChange2 have shared changes they both need before either can be released? <br />Ohh, that's tougher. You probably cannot integrate through the parent branch because you said parent is Production. Ideally you can stabilize, test, &nbsp;and release the common parts first (either cherry-picked or preferrably from a third UIChangeCommon branch). Then Forward Integrate to all active UIChangeN branches to pick up the changes. Another option would be to do a cherry-picked baseless merge between the hotfixes (which sounds worse than the original problem you described :-(&nbsp; ).</p>\n<p style=\"padding-left: 60px;\">What about testing integration of UIChange1 and UIChange2 periodically before releasing either to Production?<br />That sounds like larger change than should be done directly off Production. At this point I think these branches may belong parented to&nbsp;Trunk along with the longer running Project/feature branches.</p>\n<p><strong>Option #2: Nested UI branch for UIChange2 </strong>(if you know which change must release first)</p>\n<p style=\"padding-left: 30px;\">If you know which UI change will release first then you could start work on UIChange2 in a child branch of your existing UI branch. After first change is merged to Production and confirmed good the changes&nbsp;for UIChange2 can be merged to UI (opening child for future changes that can't go until unblocked). This is effectively creating a NEXT branch. <br /><strong>Example:</strong> Change1 started in UI branch. Change2 requires changing some of the same files as Change1 but can't wait for Change1 to finish, so Change2 starts work in UI-Next branch<br />--ProjectA<br />--ProjectB<br />--ProjectC<br />Trunk<br />--Production<br />----UI<br />------UI-Next<br /><br />PRO: Change2 doesn't get partially released with Change1.<br />CON: Assumes you know which UI change will release first. Different from \"whoever's ready next\" pattern used for Trunk. Another nested level to regularly merge (merge tax).<br />Note these changes are not going through trunk so require more merges to get these UI changes RI'd to Trunk then FI merged to all your feature dev branches.</p>\n<p><strong>Option #3: Move UIChange* branches to be children of Main (Trunk) branch</strong></p>\n<p style=\"padding-left: 30px;\">If you have parallel UI development that requires integration testing AND your trunk branch does not get locked or have pre-release artifacts hanging around then you can develop UI changes just like other features.</p>\n<p style=\"padding-left: 60px;\">What if another project/feature is merged in Trunk but not yet merged to Production branch for release?<br />Time to look back at Option #1 or Option #2.&nbsp; If you let pre-release bits sit in Trunk (for UAT or other testing) then Trunk is effectively locked for hotfixes until the pending release is pushed to Production. Otherwise you might pick up unintended changes while merging through Trunk. A locked Trunk branch is not as critical if you have hotfix branch(es) off Production. One mitigation is to always have Trunk in a shipable state. This is an ideal, but often less realistic unless you run builds and test pass on bits built in Trunk in addition to source built in Production (double-testing).</p>\n<p>You might need a combination of (#1 or #2) and #3.</p>\n<p>In all cases you need to be very careful that all RI merges to Trunk happen AFTER an RI merge has been done from Production to Trunk plus a FI merge from Trunk to feature/product branch. Otherwise you risk regressions caused by overwriting or testing without the changes already in Production. Option #3 is only pattern where the Trunk branch is really the single release vehicle. Merging any changes from current UI branch (or any \"UI#\" branch) to Production requires RI-only</p>\n<p>Good luck Rick. I Hope you or others provide some answers that do better than what I've listed above.</p>\n<p>Cheers! -Zephan</p>",
    "PostedDate": "2011-03-17T15:03:50.117-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]