[
  {
    "Id": "483980",
    "ThreadId": "224610",
    "Html": "<p>We are in the process of migrating our Visual Source Safe 2005 Database to TFS 2010.</p>\r\n<p>I'm wondering what's the best strategy for us, based on&nbsp;the actual use of VSS. Whe are a team of 10 developpers with some of them working on the whole project tree. The others are limited to severals sub&nbsp;projects.</p>\r\n<p>The Basic Branch Plan seems&nbsp;perfectly fine&nbsp;because this is exactly what we do right now from the customer perspective (One major relase, hotfixes included in the next major realease). We're currently using VSS to share a lot of C++ code between native projects, mostly sharing, sometimes branching, .cpp and .h files. On the other end, we took another approach for managed projects source code (c#). Code is no longer shared for obvious reasons, we chose to share&nbsp;binaries with the assistance of disk folders. Labels are used in both cases to track versions of the final binaries (native and managed) in order to produce hotfixes for customers.</p>\r\n<p>Our Source Safe&nbsp;database structure is basically the following :</p>\r\n<p>$/Shared Tools/Domain Projects1...N with .h/.cpp source code only (no projects/solutions files). Domains are &quot;registry&quot; or &quot;file&quot; for instance, providing reusable C++ classes that encapsulates the corresponding operations...</p>\r\n<p>$/Product 1...N&quot; with Visual Studio solution files.</p>\r\n<p>$/Product 1...N/Module 1...N with Project Files, Shared .h/.cpp files from $/shared tools sub projects and local files.</p>\r\n<p>$/Shared Tools/Domain Projects1...N with&nbsp;c# source code and&nbsp;a project file to produce the binaries that are copied to shared folders on disk. We have an ASP.NET Profile provider assembly for instance.</p>\r\n<p>$/ASP.NET Web Site&nbsp;1...N with project file and c# source code.</p>\r\n<p>The disk structure for shared libraries (managed/mixed) is like the following:</p>\r\n<p>\\\\HOST\\Libraries\\Release\\x86</p>\r\n<p>\\\\HOST\\Libraries\\Release\\x64</p>\r\n<p>\\\\HOST\\Libraries\\Release\\V1.0&nbsp;</p>\r\n<p>\\\\HOST\\Libraries\\Release\\V1.1</p>\r\n<p>\\\\HOST\\Libraries\\Release\\V1.2DEV</p>\r\n<p>The best practives for development is to always get the latest versions of all files for C++ projects. Managed projects have a file reference to the binaries on disk. Having up-to-date bits is ensured that way.</p>\r\n<p>My main concern right now is to be able to provide easy C++ code sharing the way we do it in VSS (no manual complex operations/automated operations).</p>\r\n<p>Any help appreciated.</p>\r\n<p>TIA.</p>\r\n<p>Olivier.</p>",
    "PostedDate": "2010-08-24T01:09:47.553-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "484692",
    "ThreadId": "224610",
    "Html": "<p>Olivier,</p>\r\n<p>The topic of &ldquo;shared code&rdquo; between Team Projects is a topic that this team is currently investigating and for which we are planning to add options and recommendations to the branching guidance. The shared code guidance update talks about three main techniques for sharing code, namely File Linking, Source Code Sharing and Binary (Assembly) Sharing. Whichever option you opt for, it is recommended that the common code is kept in a separate Team Project, which should maintained by a team committed to the common code. This introduces ownership and management of the common code and any revisions that may be received through reverse integration or independent submission, as well as a quality gate enforced by the common code team.</p>\r\n<p>Once you have a common code project, for example $\\Common Code\\Enterprise Library, you can share the common code through the above mentioned strategies.</p>\r\n<ol>\r\n<li>Are your projects small? \r\n<ul>\r\n<li>If yes, File Linking, which shares a reference to a source file with multiple projects and is the closest thing to VSS file sharing, may be an option.\r\n<ul>\r\n<li>When using file linking, the dependent projects are not isolated from changes to the linked file. </li>\r\n<li>This approach is generally not recommended for more than a small number of linked files and a small number of dependent projects.</li>\r\n</ul>\r\n</li>\r\n<li>Alternatively you can consider the following options:<ol>\r\n<li>Option 1 &ndash; <strong>Binary (Assembly) Sharing</strong>\r\n<ul>\r\n<li>Teams managing the common code have full ownership and control, which in theory means that the control, versioning and quality of the product is probably better, and branching and merging complexities are avoided.</li>\r\n<li>Teams re-using the common code have no access to the common source code and potentially have to wait for the team managing the common code to address features and bug resolutions.</li>\r\n<li>Some of the questions that emerge :\r\n<ul>\r\n<li>Would the common code team check the binary files into version control?</li>\r\n<li>How would the common code binaries be shared? \r\n<ul>\r\n<li>A well-known file share?&nbsp;</li>\r\n<li>A shared BIN directory within the common code team project version control?</li>\r\n<li>Copied to dependent project directories?</li>\r\n<li>Other&hellip;?</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</li>\r\n<li>Option 2 &ndash; <strong>Source Code Sharing (bi-directional)</strong>\r\n<ul>\r\n<li>Teams managing the common code share the source code by branching the code to the consuming project version control. \r\n<ul>\r\n<li>It is important to highlight that nested branches are not supported in TFS2010 and following the product group guidance you should:</li>\r\n<li>Create a&nbsp; folder within a dependent projects Team Project called share, for example $\\Product1\\Share</li>\r\n<li>Branch the Main branch of the Common Library to the Share folder of the dependent Project, for example branch $\\Common Code\\Enterprise Library\\Main to $\\ProductX\\Share\\ Enterprise Library</li>\r\n<li>Some of the questions that emerge:\r\n<ul>\r\n<li>How are changes made by the project teams using the common code reverse integrated (merged) back to the common code?</li>\r\n<li>How are changes managed to avoid incompatibilities which make a reverse integration (merge) impossible, resulting in multiple copies of the shared code?</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</li>\r\n<li>Option 3 &ndash; <strong>Source Code Sharing (uni-directional)</strong>\r\n<ul>\r\n<li>Same as option 2, except that the branched source code is made read-only, which avoids the possible nightmare of merge complexities and conflict resolution mentioned with option 2.</li>\r\n</ul>\r\n</li>\r\n</ol></li>\r\n</ul>\r\n</li>\r\n</ol>\r\n<p>So what is the recommended option? The question of scenarios and the recommended strategy is part of the branching guidance refresh and therefore we cannot give you a solid story at this point. But looking at your environment &hellip; as far as we understand in terms of managed and native (C++) code &hellip; option 3 may be the option to investigate.</p>\r\n<p>Willy</p>",
    "PostedDate": "2010-08-25T07:59:46.717-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485204",
    "ThreadId": "224610",
    "Html": "<p>Willy,</p>\r\n<p>Thanks for that.</p>\r\n<p>While searching for the nested branches restriction in TFS2010, I found this very interesting thread :</p>\r\n<p><a title=\"Dev-&gt;Main-&gt;Release for multiple products and common shared code?\" href=\"http://social.msdn.microsoft.com/Forums/en-US/tfsversioncontrol/thread/992e1d11-729d-40aa-bd07-943d3dc7ce1a\">http://social.msdn.microsoft.com/Forums/en-US/tfsversioncontrol/thread/992e1d11-729d-40aa-bd07-943d3dc7ce1a</a></p>\r\n<p>Today (thanks to the VSS &quot;share&quot; option), when a bug is found in the shared C++ classes, it is fixed by the person responsible&nbsp;for the shared code <span style=\"text-decoration:underline\">at&nbsp;the product level</span>. All other products will benefit from the fix. Now assuming that TFS is in use&nbsp;with uni-directional code sharing, as suggested in option 3, we would make the change in the Common Team Project, then branch at the product level, right ?</p>\r\n<p>To keep simplicty and to avoid breaking changes in existing code in other projects, when there is a need to add more features to the base classes, maybe it's time to add new functionnality solely&nbsp;in a new derived class. After reading the thread above, I'm pretty scared about bi-directional&nbsp;merging...</p>\r\n<p>Olivier.</p>",
    "PostedDate": "2010-08-26T07:13:59.34-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485256",
    "ThreadId": "224610",
    "Html": "<p>Olivier,</p>\r\n<p>To be clear to others, the VSS &quot;share option&quot; is most similar to the VS File Linking option. You correctly note that any developer in any of the dependent (Product) Team Projects have a *link reference* to the same source code file. Regardless of where a change is made, or by whom, this change will immediately propagate to all other dependent (Product) Team Projects as well as the *owning* Team Project.</p>\r\n<p>As with any code sharing approach, I think it is appropriate to determine who the *owner* of the code is, and what *permissions* do users of this code have to make changes.</p>\r\n<p>To clarify Option 3 Source Code Sharing, the source&nbsp;code is owned by&nbsp;a CommonLibrary owner (e.g $\\Common Code\\Enterprise Library). With uni-directional source code sharing (Option 3) the dependent (Product) teams would NOT have permission to change the shared code. Since we recommend branching the CommonLibrary from the Main branch to the dependent projects, any changes must first be in the $Common Code\\Enterprise Library\\Main branch and then merged (FI) to the dependent projects ($\\Productx\\Share\\Enterprise Library).</p>\r\n<p>The question then becomes where&nbsp;are changes to the source code made and checked in? I recommend not ever checking in changes to a Team Project's Main Branch. So, assuming we are talking about a new feature or enhancement, I would make the change in a development branch (e.g. $Common Code\\Enterprise Library\\Dev\\DevTeam01) and once it is tested, integrate (Merge&nbsp;RI)&nbsp;the change into the main branch ($Common Code\\Enterprise Library\\Dev\\DevTeam01) -&gt; $Common Code\\Enterprise Library\\Main), and from there Merge (FI) into the dependent projects ($Common Code\\Enterprise Library\\Main -&gt; $\\Productx\\Share\\Enterprise Library)</p>\r\n<p>&nbsp;I agree that Option 3 is a more controlled mechanism for sharing code and is therefore less likely to cause breaking changes than&nbsp;File Linking or Option 2.</p>\r\n<p>Again note that the branch hierarchy of the shared code is:</p>\r\n<ul>\r\n<li>\r\n<div style=\"padding-left:60px\">$Common Code\\Enterprise Library\\Main</div>\r\n<ul>\r\n<li>\r\n<div style=\"padding-left:60px\">$Common Code\\Enterprise Library\\Dev\\DevTeam01</div>\r\n</li>\r\n<li>\r\n<div style=\"padding-left:60px\">$\\Productx\\Share\\Enterprise Library</div>\r\n</li>\r\n<li>\r\n<div style=\"padding-left:60px\">$\\Producty\\Share\\Enterprise Library</div>\r\n</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n<p>There is no merge releationship between the product branches and the shared code branch within the product team projects</p>\r\n<ul>\r\n<li>\r\n<div style=\"padding-left:60px\">$\\Productx\\Main</div>\r\n</li>\r\n<li>\r\n<div style=\"padding-left:60px\">$\\Productx\\Share\\Enterprise Library</div>\r\n</li>\r\n</ul>\r\n<p>Or you could add these features, as you suggest, in a derived class of a shared class that is in the Product's Team Project. This type of enhancemen would typically be scoped (restricted to) the Product where the derived class exists (not shared with other Products).</p>\r\n<p>I would also note that Option 1, using binary references is a typical way that I reference shared code (such as Enterprise Library). I don't necessarily want to build all of the code in enterprise library everytime I build my dependent project(s). Option 1 would be faster build (or compile) than Options 2 or 3.</p>\r\n<p>Regards,<br>Bill Heys<br>VS ALM Ranger</p>\r\n<p style=\"padding-left:60px\">&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-08-26T08:54:25.307-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485297",
    "ThreadId": "224610",
    "Html": "<p>Typically one would use Binary (Asssembly) references for third-party shared components.&nbsp;In this scenario, you might not have access to the third-party source code. Such third party components might need to be installed on all developer machines (as well as build machines). Typically you would reference the assemblies from wherever the install process&nbsp;deploys them (such as the GAC).</p>\r\n<p>Further, one would&nbsp;prefer Binary (Assembly) references over&nbsp;Source (Project) references for very large solutions with many projects. When you&nbsp;use&nbsp;project references all&nbsp;of the projects are compiled on a full build. The is&nbsp;true even when none of the shared&nbsp;source&nbsp;code has&nbsp;changed. Compile and build times&nbsp;on these&nbsp;very large solutions will be noticably impacted by having to recompile all shared source projects.</p>\r\n<p>When you use&nbsp;Assembly references you can store the assemblies&nbsp;locally in the solution (Team Project). This has the advantage that, once copied to a folder within the Team Project / Solution, it can be checked into source control. Automated builds can get the correct assemblies from source control (get latest).</p>\r\n<p>Alternatively you can store the assemblies in a well-known location (such as a network file share). This network share needs to be accessible for developers when they build locally as well as automated builds.</p>\r\n<p>Finally you can store the assemblies in the Global Assembly Cache (GAC). This is a good approach for signed assemblies.</p>\r\n<p>A benefit of assembly references is that you have support for side-by-side versions. Each dependent project can reference a specific version of the shared code (or component). Other dependent projects can reference different versions of this same shared code (or component). Changing which version of shared code (or component) your solution references (or to pick up&nbsp;changes)&nbsp;is simply a matter of copying the appropriate assemblies (DLLs) into the shared binary folder within the solution.</p>\r\n<p>When you use project references, you are typically using branching and merging (rather than file copying) to manage version control and updates.<br><br>Regards,<br>Bill Heys<br>VS ALM Rangers</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-08-26T10:18:28.73-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486364",
    "ThreadId": "224610",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>wheys wrote:</strong><br>\r\n<p>To be clear to others, the VSS &quot;share option&quot; is most similar to the TFS File Linking option. You correctly note that any developer in any of the dependent (Product) Team Projects have a *link reference* to the same source code file. Regardless of where a change is made, or by whom, this change will immediately propagate to all other dependent (Product) Team Projects as well as the *owning* Team Project.</p>\r\n</blockquote>\r\n<p>Is the TFS Linking option provided by TFS or Visual Studio ? Could you point me to this feature's documentation ?</p>",
    "PostedDate": "2010-08-30T05:14:38.577-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486367",
    "ThreadId": "224610",
    "Html": "<p>I apologize for the type. It is a Visual Studio option, not a TFS option. I should have said VS File Linking (I corrected my post above). To use this feature, again for a small number of shared files, use the Add Existing Item menu. When you browse to the desired file you want to add to your project, you can choose from the *dropdown button* and select *Add* or *Add as Link*</p>\r\n<p>Regards,</p>\r\n<p>Bill Heys<br>VS ALM Ranger</p>",
    "PostedDate": "2010-08-30T05:25:05.267-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486400",
    "ThreadId": "224610",
    "Html": "<p>Finally, to take advdantage of all the features of Branching and Merging in TFS2010 after importing data from Visual Source Safe, is the 'Convert Folder to Branch' step the last thing to do after the initial import ? Is the baseless merge facility&nbsp;for C++ shared code usefull in my situation ?&nbsp;Any other suggestions ?</p>\r\n<p>&nbsp;</p>\r\n<p>Kind Regards,</p>\r\n<p>Olivier.</p>",
    "PostedDate": "2010-08-30T06:36:04.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486410",
    "ThreadId": "224610",
    "Html": "<p>Olivier,</p>\r\n<p>At some point you will want to convert your *main* folder to a branch. I am not sure what your lists of steps are, so I am not sure it is the *last* step or not.</p>\r\n<p>Perhaps you can explain why you feel you need a baseless merge, and what branches would be the source and target of this merge. I generally try to discourage doing baseless merges for a variety of reasons. A key reason is to avoid a confusing *matrix* of merge relationships where a branch has a merge relationship with many other branches (not simply its direct parent and children).</p>\r\n<p>It is sometimes necessary to do a baseless merge. There are times when I have to do a baseless merge to fix a problem that I cannot fix through normal merge relationships or to invoke options that are not available through the UI.</p>\r\n<p>Regards,<br>Bill Heys<br>VS ALM Ranger</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-08-30T06:53:58.997-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486421",
    "ThreadId": "224610",
    "Html": "<p>I was thinking that I would convert the main folder (ie : $/ ) to a branch right after the data import from Visual Source Safe.</p>\r\n<p>About Baseless Merge, I was reffering about the reply marked as answer in this other thread : <a title=\"Baseless Merge ?\" href=\"http://social.msdn.microsoft.com/forums/en-US/tfsgeneral/thread/3e4efc40-45c3-4242-a4cb-f38610961512/\">http://social.msdn.microsoft.com/forums/en-US/tfsgeneral/thread/3e4efc40-45c3-4242-a4cb-f38610961512/</a>.</p>\r\n<p>Kind Regards,</p>\r\n<p>Olivier.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-08-30T07:24:57.753-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486427",
    "ThreadId": "224610",
    "Html": "<p>Given your VSS source structure at the beginning of this thread, it would be helpful to understand more of what your target TeamProject/Branch/Folder structure will be.</p>\r\n<p>You mention that you have Product 1...N. Are these each going to be in their own TeamProject?&nbsp; Are all Products developed and released on the same schedule?</p>\r\n<p>Knowing more about why your code is structured the way it is in VSS today will help me guide you in the right direction. In other words, I am not sure you will necessarily end up with a single Team Project and Main folder (branch)</p>\r\n<p>While dated, I believe the thread you reference above is a valid approach, where for&nbsp;a single Team Project / Product, you have multiple VSS folders that are similar to the basic branch plan in TFS (e.g. Main folder, Dev folder, Release folder, etc)</p>\r\n<p>Since you would not have a hierarchical relationship between the VSS folders (Main -&gt; Dev) when you bring the folders over from VSS, you could use a baseless merge to allow you to create a merge relationship, and then even reparent the child folders to the parent folders in VS 2010.</p>\r\n<p>Bill Heys</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-08-30T07:56:46.03-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486441",
    "ThreadId": "224610",
    "Html": "<p>I would strongly strongly advise against having multiple team projects. From what we've learned at Microsoft the &quot;Big&quot; divisions have enforced using 1, and&nbsp;only 1, team project for the entire division with many many branches under that 1 team project and using areas and iterations to seperate work items.</p>\r\n<p>Think about that for a second 2500~3000 people on the Visual Studio Teams(including the .Net Framework team)&nbsp;use only 1 team project.</p>\r\n<p>I&nbsp;want to warn you about a bug (a pretty severe bug IMHO) in having multiple team projects. <a href=\"http://social.msdn.microsoft.com/Forums/en-US/tfsversioncontrol/thread/a71ac2f0-dc9c-4c03-a6a3-ab59877c55d8\">http://social.msdn.microsoft.com/Forums/en-US/tfsversioncontrol/thread/a71ac2f0-dc9c-4c03-a6a3-ab59877c55d8</a>.</p>\r\n<p>My recommendation would be when migrating from VSS to TFS to migrate your history to a folder (say $/Archive) and then create a new branching structure following the &quot;standard&quot; branching plan from the rangers guidance.</p>",
    "PostedDate": "2010-08-30T08:28:06.71-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "486753",
    "ThreadId": "224610",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>wheys wrote:</strong><br>\r\n<p>Given your VSS source structure at the beginning of this thread, it would be helpful to understand more of what your target TeamProject/Branch/Folder structure will be.</p>\r\n<p>You mention that you have Product 1...N. Are these each going to be in their own TeamProject?&nbsp; Are all Products developed and released on the same schedule?</p>\r\n<p>Knowing more about why your code is structured the way it is in VSS today will help me guide you in the right direction. In other words, I am not sure you will necessarily end up with a single Team Project and Main folder (branch)</p>\r\n</blockquote>\r\n<p>My first guess is that I won't use several Team Projects.</p>\r\n<p>1) All products developped are not released on the same schedule, we switch&nbsp;from/to developpement/release between them as needed, but we may&nbsp;temporaily switch&nbsp;back&nbsp;anytime a fix is needed.&nbsp;In my mind, this is where the benefits brought by the&nbsp;basic branch plan comes in with TFS (as opposed to the current use of labels in VSS to achieve the same goal and to avoid regression in shared code).</p>\r\n<p>2) I would like to continue providing code sharing between projects for &quot;system services&quot; (like file and registry operations...), carefully dealing with FI and RI between projects and shared code.</p>\r\n<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>wheys wrote:</strong>\r\n<p>While dated, I believe the thread you reference above is a valid approach, where for&nbsp;a single Team Project / Product, you have multiple VSS folders that are similar to the basic branch plan in TFS (e.g. Main folder, Dev folder, Release folder, etc)</p>\r\n<p>Since you would not have a hierarchical relationship between the VSS folders (Main -&gt; Dev) when you bring the folders over from VSS, you could use a baseless merge to allow you to create a merge relationship, and then even reparent the child folders to the parent folders in VS 2010.</p>\r\n<p>Bill Heys</p>\r\n</blockquote>\r\n<p>&nbsp;Thanks for that, this not our folder structure in VSS at this time.</p>\r\n<p>Kind Regards,</p>\r\n<p>Olivier.</p>",
    "PostedDate": "2010-08-30T23:20:29.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]