[
  {
    "Id": "520035",
    "ThreadId": "234178",
    "Html": "\r\n<p>Hello -</p>\r\n<p>&nbsp;&nbsp;I'm in the process of migrating from VSS 2005 to TFS 2010. &nbsp; &nbsp;From what I have read a Basic branching plan will work for us.&nbsp;</p>\r\n<p>&nbsp;&nbsp;But the issue i'm struggling with is how to automate our build process in TFS. &nbsp; &nbsp;As a development team we are use to 'cherry picking' what gets put into certification. &nbsp;This does not appear to be recommended for TFS.</p>\r\n<p>&nbsp;&nbsp; I'll explain how our build process current works using VSS. &nbsp;</p>\r\n<p>&nbsp;&nbsp;1. &nbsp;We have a $/Dev/Src folder where all developers check in their code.</p>\r\n<p>&nbsp;&nbsp;2. &nbsp;When they check in their code they are prompted to enter a point number to tie the code items to. &nbsp; &nbsp;The tool that prompts the developer is a Visual Studio and Visual Source Safe Add-In. &nbsp; &nbsp;The tool lets the user\r\n enter a point number then writes a database record specifying the point number, vss file path and vss file version.</p>\r\n<p>&nbsp;&nbsp; &nbsp;the database table looks like this...</p>\r\n<p>&nbsp;&nbsp; &nbsp;PointID &nbsp;: The point number from our point / issue tracking system.</p>\r\n<p>&nbsp;&nbsp; &nbsp;FileName : &nbsp;The path to the file in Source Safe</p>\r\n<p>&nbsp;&nbsp; &nbsp;Version: &nbsp; The version of the file in Source.</p>\r\n<p>&nbsp;&nbsp; &nbsp;Cert Date: &nbsp;Date the file was pinned in the cert branch.</p>\r\n<p>&nbsp;3. &nbsp;In VSS we have a $/Cert/Src folder which is shared from the $/Dev/Src folder. &nbsp; &nbsp;All the code files in this trunk are pinned. &nbsp;The pinning is maintained in the next step...</p>\r\n<p>4. &nbsp;When we want to build code to certification we have an access database where we enter the point numbers. &nbsp; The access database uses the VSS API to &nbsp;pin each version of all files tied to all points in the list of points entered by the build\r\n user (in the $/Cert/Src trunk). &nbsp; &nbsp; &nbsp; &nbsp;For example, &nbsp;if point 1000 has file1.cs version 10 checked into it, the access database would pin file1.cs to version 10 when building point 1000.</p>\r\n<p>&nbsp;&nbsp;5. &nbsp;We then use FinalBuilder to get latest version of all code in the $/Cert/Src folder, perform the build and copy it to the appropriate location. &nbsp;As you know, getting pinned code means you get that version of the code regardless\r\n of the number of revisions checked in afterward.</p>\r\n<p>&nbsp;&nbsp;This basic process has been in place for 7 years and works well. &nbsp;Sure we run into dependency problems at times, but our Visual Studio / VSS Addin also prompts the developers when they start checking out a code file if the code file is tied\r\n to a point that is currently marked 'in cert'. &nbsp; &nbsp;So they might hold off on working on that file until the change is completed and in production. &nbsp;&nbsp;</p>\r\n<p>&nbsp;&nbsp;All of my web research says you should not cherry pick changes to move between branches. &nbsp; &nbsp; I don't think I can sell our organization on not cherry picking what changes move into the next QA cycle. &nbsp; &nbsp;</p>\r\n<p>&nbsp;Also, &nbsp;in TFS I assume work items are similar to our points. &nbsp; I'm assuming a changeset is a snapshot of all code items when a check in occurred (even those items not explicitly checked out and changed). &nbsp;<span style=\"color:#0000ff\">Are\r\n my assumptions correct?</span></p>\r\n<p>&nbsp;&nbsp;A couple other notes about our current build process</p>\r\n<p>&nbsp;&nbsp; &nbsp; -Our applications are used in house only, not products we sell to customers. &nbsp; So our production build consists of copying certification code to production. &nbsp;This is true for our windows and web applications. &nbsp;<span style=\"color:#0000ff\">Would\r\n we really need a release branch?</span></p>\r\n<p>&nbsp;&nbsp; &nbsp; &nbsp; -To build our development code we simply get all code from $/Dev/Src and perform a build.</p>\r\n<p>&nbsp;&nbsp;I am doing some test team projects and visual studio solutions to work out the details of build automation &nbsp;but was hoping someone could give any guidance.</p>\r\n<p>&nbsp;&nbsp;I apologize if this is not the correct place to ask this question. &nbsp;I would appreciate a pointer to somewhere else to ask this question if this is not the correct place.</p>\r\n<p>&nbsp;&nbsp;Thanks&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2010-11-10T08:38:46.21-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "520048",
    "ThreadId": "234178",
    "Html": "\r\n<p>Your VSS $/Dev/Src folder would be similar to the Dev branch in the basic branch plan. The Dev branch in this plan is a full child of the Main (top level) branch</p>\r\n<p>Your point number seems to be similar to a changeset ID. I am assuming that *only* the code items that are checked-in together are tied to a given point number.</p>\r\n<p>As you probably know, TFS does not have the same concept as shared code or pinned code</p>\r\n<p>As a general rule, in TFS the recommended process would be:</p>\r\n<ol>\r\n<li>When the code in Dev is ready for Cert (it passes quality gates and builds), Merge the latest code in Dev to Main\r\n</li><li>Build the code in Main and deploy to QA </li><li>You can consider using labels in TFS to mark a milestone, but labels are NOT immutable in TFS - this means that changes can be made to the files and versions of files within the label.\r\n</li></ol>\r\n<p>I believe the isolation offered between the Main and Dev branches should eliminate the need to do cherry picking for a Cert build</p>\r\n<p>This isolation should also minimize the problem where a developer needs to wait while code is being stabilized and moved to production (stabilization happens in the Main branch while development happens in the Dev branch)</p>\r\n<p>TFS work items do not seem to be similar to your points. As I indicated earlier, from what I understand, your points seem to be most similar to a Changeset ID which is generated on a check-in of one or more files.</p>\r\n<p>When you check-in one or more files as part of a change-set you have the option in TFS of associating one or more work-items with the changeset. Typically these work-items would be tasks or bugs. For example if a bug is reported, when a developer makes a\r\n code change to resolve the bug, the bug work item would be associated with this check-in of the fixed code.</p>\r\n<p>Typically you need a release branch to isolate released code from ongoing development. The Release branch is vCurrent (for example v1.0), the Development branch is vNext (for example v1.1 or v2.0) and the Main branch is used for stabilizing code from development\r\n to get it ready for release. If you have a post-release bug that you need fixed, having the Release branch with an exact copy of your production code enables you to quickly fix the bug. It is conceivable that the Main branch already has vNext code and it would\r\n not be advisable to do a hotfix for production here.</p>\r\n<p>A Changest is not a snapshot of all code items at the time of a check-in. It is a record of the changes to files that are part of the check-in only. A *snapshot* in TFS is more along the lines of a label. Files that are not explicitly checked out and changed\r\n would never be associated with a changeset but would be associated with a label.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger</p>\r\n",
    "PostedDate": "2010-11-10T09:02:33.04-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "520097",
    "ThreadId": "234178",
    "Html": "\r\n<p>Bill -</p>\r\n<p>&nbsp;&nbsp;I very much appreciate your quick response! &nbsp; &nbsp; Coming from the VSS world I keep thinking in terms of shared and &nbsp;pinned code and trying to apply that to TFS. &nbsp; &nbsp;I need to remove my VSS lenses to actually see what TFS\r\n is. &nbsp;:-). &nbsp;I'll admit it has not been easy for me.&nbsp;</p>\r\n<p>&nbsp;&nbsp;You are correct that *only* the code items checked-in are tied to a given point number. &nbsp; &nbsp; The reason I thought they tied to work items was because our users create the point numbers which we then tie code files to. &nbsp; A point\r\n can be a bug, new feature, etc. &nbsp; &nbsp; &nbsp; &nbsp;As you pointed out, changesets are generated when the code is checked in. &nbsp; &nbsp;</p>\r\n<p>&nbsp;&nbsp;To utilize our existing point tracking system I could hook into the TFS automation model and when a changeset is created tie it to a point number. &nbsp;&nbsp;</p>\r\n<p>&nbsp;&nbsp;A few more questions....</p>\r\n<p>&nbsp;&nbsp;1. &nbsp;How do you communicate to your testers what is ready for testing? &nbsp;Users don't have a concept of changesets, but i'm assuming they do deal with work items or some issue tracking system. &nbsp; But you integrate changesets. &nbsp;\r\n &nbsp; So whoever is responsible for the QA build performs the integration and then queries what workitems just were included in the integrated changesets? &nbsp; Or am I totally missing something?</p>\r\n<p>&nbsp;&nbsp;2. &nbsp; When you say the isolation between the Main and Dev branches should eliminate the need to cherry pick for a cert build - but don't times exist when we don't want to push all changesets from Dev to Main? &nbsp; &nbsp;Or am I still looking\r\n at things from a VSS perspective? &nbsp; &nbsp;We have times when a larger change might be ready for QA but the testers are not ready to test it. &nbsp; &nbsp; So we push other code to QA and when the users have more bandwidth for testing we push out the larger\r\n change. &nbsp;Of course, we run into dependency issues where a larger change has to move into QA because it touches the same code files as other changes.</p>\r\n<p>&nbsp;3. &nbsp; &nbsp;I have some questions on the paragraph that starts with &nbsp;-\r\n<em>Typically you need a release branch to isolate released code from ongoing development</em>. &nbsp; &nbsp; But I want to think it through some more before asking.</p>\r\n<p>&nbsp;Thanks for your help again Bill.</p>\r\n<p>&nbsp;&nbsp;Rob&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2010-11-10T09:57:33.79-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "520114",
    "ThreadId": "234178",
    "Html": "\r\n<p>Rob,</p>\r\n<p>1. Yes. It is possible to do a Work Item query to determine all work items (tasks, bugs) that were associated with changesets since the last build deployed to QA. This is why it is very important for developers (and others) to follow the policy of associating\r\n all of the appropriate work items to a changeset at check-in time.</p>\r\n<p>2. As a general rule, you would want QA to test all of the changes from DEV that have been pushed to MAIN. In this case you probably want to merge *All Changes up to Latest Version*. In your example, where you do&nbsp;not want all changes from Development\r\n to be sent to QA, cherry picking might be a good option. Be aware that when you cherry pick changes,&nbsp;you may be merging a&nbsp;code state that&nbsp;does not build&nbsp;or that does not&nbsp;include all of the changesets for a particular feature you want&nbsp;to\r\n test. There is also the possibility&nbsp;of future merge conflicts when you do a cherry picking merge followed by a merge from latest version, etc.</p>\r\n<p>Regards,</p>\r\n<p>Bill<br>\r\nVS ALM Ranger&nbsp;</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2010-11-10T10:45:53.313-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "520121",
    "ThreadId": "234178",
    "Html": "\r\n<p>Rob,</p>\r\n<p>Trying to play devils advocate here.</p>\r\n<p>When you do a merge you have&nbsp;several options:</p>\r\n<ul>\r\n<li>Merge Selected Changesets </li><li>Merge All Changes up to:\r\n<ul>\r\n<li>the Latest Version </li><li>A Changeset </li><li>A Date </li><li>A Label </li><li>Workspace Versio </li></ul>\r\n</li></ul>\r\n<p>I am not sure if labelling helps you out here, or perhaps feature team branching where different features are developed in different development branches.</p>\r\n<p>It maybe that the *larger change* you mention is part of one feature, but perhaps it is a set of features. Dividing the development into separate feature branches would allow you to merge the changes from one feature team branch (or deploy to qa directly\r\n from that branch) without including the changes from other features in other branches.</p>\r\n<p>Regards,<br>\r\nBill Heys<br>\r\nVS ALM Ranger.</p>\r\n",
    "PostedDate": "2010-11-10T10:54:18.177-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "520125",
    "ThreadId": "234178",
    "Html": "\r\n<p>Bill -</p>\r\n<p>&nbsp;&nbsp;I very much appreciate your input!</p>\r\n<p>&nbsp;I'll digest all this information and continue to do some testing. &nbsp;</p>\r\n<p>&nbsp;I will probably repost later when I have a better grasp of everything.</p>\r\n<p>&nbsp;Thanks again for your time Bill.</p>\r\n<p>&nbsp;&nbsp;Have a good day -&nbsp;</p>\r\n<p>&nbsp;&nbsp;Rob&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2010-11-10T11:02:51.677-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]